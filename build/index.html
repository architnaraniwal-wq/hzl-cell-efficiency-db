<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HZL - Cell Efficiency Monitoring</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.6.0/jspdf.plugin.autotable.min.js"></script>
  <style>
    :root {
      --primary: #2E7D6F;
      --primary-dark: #1B5E50;
      --primary-light: #E0F2EF;
      --bg: #F5F6FA;
      --white: #FFFFFF;
      --border: #E2E8F0;
      --text-primary: #1A202C;
      --text-secondary: #64748B;
      --text-muted: #94A3B8;
      --excellent-bg: #DCFCE7;
      --excellent-text: #16A34A;
      --excellent-border: #22C55E;
      --good-bg: #FFF7ED;
      --good-text: #EA580C;
      --good-border: #F97316;
      --bad-bg: #FEF2F2;
      --bad-text: #DC2626;
      --bad-border: #EF4444;
      --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
      --shadow-lg: 0 4px 12px rgba(0,0,0,0.12);
      --radius: 8px;
      --radius-sm: 6px;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ============ HEADER ============ */
    #main-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--white);
      padding: 10px 24px;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: var(--shadow);
    }
    .logo-section img {
      height: 44px;
      object-fit: contain;
    }
    .title-section h1 {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.3px;
    }
    .actions-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .settings-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: var(--radius-sm);
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .settings-btn:hover { background: var(--bg); }
    .settings-btn svg {
      width: 26px;
      height: 26px;
      color: #64748B;
      transition: color 0.2s;
    }
    .settings-btn:hover svg { color: #334155; }

    /* ============ MAIN NAVIGATION (top-level) ============ */
    #sub-nav {
      display: flex;
      gap: 0;
      padding: 0 24px;
      background: var(--white);
      border-bottom: 1px solid var(--border);
    }
    .sub-nav-tab {
      padding: 16px 28px;
      font-size: 15px;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      position: relative;
      transition: color 0.2s;
      white-space: nowrap;
    }
    .sub-nav-tab:hover {
      color: var(--text-primary);
    }
    .sub-nav-tab.active {
      color: var(--primary-dark);
      font-weight: 700;
    }
    .sub-nav-tab.active::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 12px;
      right: 12px;
      height: 3px;
      background: var(--primary-dark);
      border-radius: 3px 3px 0 0;
    }

    /* ============ SIDE TABS (sub-level) ============ */
    #side-tabs {
      display: flex;
      gap: 0;
      padding: 10px 24px 0;
      background: var(--bg);
    }
    .side-tab {
      padding: 8px 22px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      transition: all 0.2s;
      user-select: none;
      border: 1px solid transparent;
      border-bottom: none;
      position: relative;
    }
    .side-tab.active {
      background: var(--white);
      color: var(--primary);
      border-color: var(--border);
      box-shadow: 0 -2px 6px rgba(0,0,0,0.04);
    }
    .side-tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--white);
    }
    .side-tab:not(.active) {
      background: transparent;
      color: var(--text-secondary);
    }
    .side-tab:not(.active):hover {
      background: rgba(255,255,255,0.5);
      color: var(--text-primary);
    }

    /* ============ MAIN CONTENT AREA ============ */
    #content-area {
      background: var(--white);
      margin: 0 24px 24px;
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    /* ============ CONTROLS BAR ============ */
    #controls-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--white);
      flex-wrap: wrap;
      position: relative;
      z-index: 20;
    }

    /* ============ CUSTOM DROPDOWNS (matching DropDown.png) ============ */
    .custom-dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      background: var(--white);
      border: 1.5px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      transition: border-color 0.2s, box-shadow 0.2s;
      min-width: 160px;
      justify-content: space-between;
    }
    .dropdown-toggle:hover {
      border-color: #CBD5E1;
    }
    .dropdown-toggle.open {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(46,125,111,0.1);
    }
    .dropdown-chevron {
      font-size: 10px;
      color: var(--text-secondary);
      transition: transform 0.2s;
    }
    .dropdown-toggle.open .dropdown-chevron {
      transform: rotate(180deg);
    }
    .dropdown-menu {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      min-width: 100%;
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-lg);
      z-index: 200;
      display: none;
      overflow: hidden;
    }
    .dropdown-menu.show { display: block; }
    .dropdown-item {
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.15s;
      white-space: nowrap;
    }
    .dropdown-item:hover {
      background: var(--bg);
    }
    .dropdown-item.active {
      color: var(--primary);
      font-weight: 600;
    }

    /* ============ CUSTOM DATE RANGE ============ */
    #custom-date-range {
      display: none;
      align-items: center;
      gap: 8px;
    }
    #custom-date-range.show { display: flex; }
    #custom-date-range input[type="date"] {
      padding: 7px 10px;
      border: 1.5px solid var(--border);
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-family: inherit;
      color: var(--text-primary);
    }
    #custom-date-range .date-label {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
    }
    .apply-btn {
      padding: 7px 16px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    .apply-btn:hover { background: var(--primary-dark); }

    .rej-settings-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 18px;
      background: var(--text-primary);
      color: #FFFFFF;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
      font-family: inherit;
    }
    .rej-settings-btn:hover {
      background: #334155;
    }
    .rej-settings-btn svg { flex-shrink: 0; }

    .ma-toggle-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 7px 14px;
      background: var(--primary-dark);
      color: #FFFFFF;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .ma-toggle-btn:hover {
      background: var(--primary);
      box-shadow: 0 2px 4px rgba(46,125,111,0.15);
    }
    .ma-toggle-btn svg { flex-shrink: 0; }
    .ma-toggle-btn.active {
      background: var(--primary);
    }
    .ma-toggle-btn.active:hover {
      background: var(--primary-dark);
    }

    /* ============ LOADING ============ */
    #loading-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.85);
      z-index: 500;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 16px;
    }
    #loading-overlay.show { display: flex; }
    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--border);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .spinner-small {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #E5E7EB;
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #loading-text {
      font-size: 14px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    /* ============ TABLE ============ */
    #table-container {
      overflow: auto;
      max-height: calc(100vh - 200px);
      position: relative;
      -webkit-overflow-scrolling: touch;
    }
    #heatmap-table {
      width: max-content;
      min-width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 12px;
    }
    #heatmap-table thead th {
      background: #FAFBFC;
      font-weight: 500;
      font-size: 13px;
      color: #4A5568;
      text-transform: none;
      letter-spacing: 0;
      padding: 14px 12px;
      text-align: center;
      border-bottom: 1px solid #EDF2F7;
      position: sticky;
      top: 0;
      z-index: 10;
      white-space: nowrap;
    }
    #heatmap-table thead th:first-child {
      position: sticky;
      z-index: 12;
      left: 0;
      background: #FAFBFC;
    }
    #table-container:not(.mode-combined) #heatmap-table thead th:nth-child(2) {
      position: sticky;
      z-index: 12;
      left: 100px;
      background: #FAFBFC;
    }
    #heatmap-table tbody td {
      padding: 6px 8px;
      text-align: center;
      border-bottom: 1px solid #F1F5F9;
      font-weight: 500;
      font-size: 12px;
      white-space: nowrap;
      min-width: 60px;
      transition: background 0.15s;
    }
    #heatmap-table tbody tr:hover td {
      filter: brightness(0.97);
    }
    .col-cellno, .col-selection {
      position: sticky;
      z-index: 5;
      background: #FFFFFF !important;
      border-right: 1px solid var(--border);
    }
    .col-cellno {
      left: 0;
      min-width: 100px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .cell-num-label {
      font-weight: 700;
      color: var(--primary-dark);
      font-size: 12px;
      cursor: pointer;
      transition: color 0.15s, text-decoration 0.15s;
      text-decoration: underline;
      text-decoration-color: transparent;
      text-underline-offset: 2px;
    }
    .cell-num-label:hover {
      color: var(--primary);
      text-decoration-color: var(--primary);
    }
    .col-selection {
      left: 100px;
      min-width: 50px;
      font-weight: 600;
      color: var(--text-secondary);
      font-size: 11px;
    }
    .col-avg {
      background: #F8FAFC !important;
      font-weight: 700 !important;
      position: sticky;
      right: 110px;
      z-index: 6;
      border-left: 2px solid var(--border);
      min-width: 100px;
    }
    .mode-combined .col-avg,
    .mode-combined th.col-avg,
    .mode-rejection .col-avg,
    .mode-rejection th.col-avg {
      right: 0;
    }
    #heatmap-table thead th.col-avg {
      z-index: 13;
      background: #FAFBFC !important;
    }
    #heatmap-table thead th.col-excellent {
      z-index: 13;
      background: #FAFBFC !important;
    }
    .col-excellent {
      position: sticky;
      right: 0;
      z-index: 6;
      border-left: 2px solid var(--border);
      min-width: 110px;
      font-weight: 700 !important;
      background: #FFFFFF !important;
    }

    /* Color coding */
    .cell-excellent {
      background: var(--excellent-bg) !important;
      color: var(--excellent-text) !important;
    }
    .cell-good {
      background: var(--good-bg) !important;
      color: var(--good-text) !important;
    }
    .cell-bad {
      background: var(--bad-bg) !important;
      color: var(--bad-text) !important;
    }
    .cell-nodata {
      background: #FAFAFA !important;
      color: #CBD5E1 !important;
    }

    /* Summary rows */
    .row-avg td {
      background: #F0F9FF !important;
      font-weight: 700 !important;
      border-top: 2px solid var(--primary) !important;
      font-size: 14px;
      padding: 10px 8px;
    }
    .row-avg td.col-cellno,
    .row-avg td.col-avg {
      background: #F0F9FF !important;
    }
    .row-dist td {
      font-weight: 700 !important;
      font-size: 13px;
      border-top: 1px solid var(--border);
    }
    .row-dist-excellent td { color: var(--excellent-text) !important; }
    .row-dist-good td { color: var(--good-text) !important; }
    .row-dist-bad td { color: var(--bad-text) !important; }
    .row-dist td.col-cellno {
      background: var(--white) !important;
      font-size: 11px;
    }
    .row-dist-excellent td.col-cellno { color: var(--excellent-text) !important; }
    .row-dist-good td.col-cellno { color: var(--good-text) !important; }
    .row-dist-bad td.col-cellno { color: var(--bad-text) !important; }
    .row-dist td.col-selection {
      background: var(--white) !important;
    }

    /* Row borders between cell groups */
    .cell-group-start td {
      border-top: 1.5px solid var(--border);
    }

    /* ============ MODALS ============ */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.4);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(2px);
    }
    .modal-overlay.show {
      display: flex;
    }

    /* Password Modal (matching Set Pass.png) */
    .password-modal {
      background: var(--white);
      border-radius: 16px;
      padding: 40px 48px 36px;
      width: 420px;
      max-width: 90vw;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.15);
    }
    .lock-icon {
      margin-bottom: 16px;
    }
    .lock-icon svg {
      width: 40px;
      height: 40px;
    }
    .password-modal h2 {
      font-size: 22px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 8px;
    }
    .password-modal .subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 28px;
    }
    .passcode-input {
      width: 100%;
      padding: 14px 18px;
      border: 2.5px solid var(--primary);
      border-radius: 10px;
      font-size: 16px;
      font-family: inherit;
      letter-spacing: 4px;
      text-align: center;
      outline: none;
      color: var(--text-primary);
      margin-bottom: 28px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .passcode-input:focus {
      box-shadow: 0 0 0 4px rgba(46,125,111,0.15);
    }
    .passcode-input.error {
      border-color: var(--bad-border);
      box-shadow: 0 0 0 4px rgba(239,68,68,0.1);
      animation: shake 0.4s;
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-6px); }
      75% { transform: translateX(6px); }
    }
    .modal-buttons {
      display: flex;
      gap: 12px;
    }
    .btn-cancel {
      flex: 1;
      padding: 12px;
      border: 1.5px solid var(--border);
      border-radius: 10px;
      background: var(--white);
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-cancel:hover { background: var(--bg); }
    .btn-unlock {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 10px;
      background: var(--primary);
      font-size: 15px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-unlock:hover { background: var(--primary-dark); }

    /* Export Dropdown */
    .export-dropdown {
      position: relative;
      display: inline-block;
    }
    .export-btn {
      background: var(--primary);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: background 0.2s;
    }
    .export-btn:hover {
      background: var(--primary-dark);
    }
    .export-btn svg {
      width: 16px;
      height: 16px;
    }
    .export-dropdown-menu {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      background: white;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      z-index: 50;
      min-width: 160px;
      overflow: hidden;
    }
    .export-dropdown-item {
      padding: 10px 14px;
      width: 100%;
      text-align: left;
      background: none;
      border: none;
      font-size: 13px;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.2s;
      display: block;
    }
    .export-dropdown-item:hover {
      background: #f1f5f9;
    }
    .export-dropdown-item:not(:last-child) {
      border-bottom: 1px solid #f0f0f0;
    }

    /* Settings Modal (matching CE Setting.png) */
    .settings-modal {
      background: var(--white);
      border-radius: 16px;
      padding: 32px;
      width: 560px;
      max-width: 90vw;
      box-shadow: 0 20px 60px rgba(0,0,0,0.15);
    }
    .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
    }
    .settings-header h2 {
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 4px;
      line-height: 1;
      transition: color 0.2s;
    }
    .close-btn:hover { color: var(--text-primary); }

    .setting-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      border: 2px solid;
      border-radius: 12px;
      margin-bottom: 12px;
    }
    .setting-row.excellent { border-color: var(--excellent-border); background: rgba(34,197,94,0.03); }
    .setting-row.good { border-color: var(--good-border); background: rgba(249,115,22,0.03); }
    .setting-row.bad { border-color: var(--bad-border); background: rgba(239,68,68,0.03); }

    .setting-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }
    .setting-row.excellent .setting-icon { background: var(--excellent-bg); color: var(--excellent-text); }
    .setting-row.good .setting-icon { background: var(--good-bg); color: var(--good-text); }
    .setting-row.bad .setting-icon { background: var(--bad-bg); color: var(--bad-text); }

    .setting-label {
      font-weight: 600;
      font-size: 14px;
      min-width: 70px;
    }
    .setting-row.excellent .setting-label { color: var(--excellent-text); }
    .setting-row.good .setting-label { color: var(--good-text); }
    .setting-row.bad .setting-label { color: var(--bad-text); }

    .setting-inputs {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }
    .input-label {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
    }
    .setting-input {
      width: 64px;
      padding: 8px 10px;
      border: 1.5px solid var(--border);
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-family: inherit;
      text-align: center;
      font-weight: 600;
      color: var(--text-primary);
      outline: none;
      transition: border-color 0.2s;
    }
    .setting-input:focus {
      border-color: var(--primary);
    }

    .range-preview {
      border: 1.5px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin: 20px 0;
    }
    .range-preview-label {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
      margin-bottom: 10px;
    }
    .range-bar {
      display: flex;
      height: 28px;
      border-radius: 6px;
      overflow: hidden;
    }
    .range-segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      color: white;
    }
    .range-bad { background: #FCA5A5; color: #991B1B; }
    .range-good { background: #FDBA74; color: #9A3412; }
    .range-excellent { background: #86EFAC; color: #166534; }

    .settings-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 20px;
    }
    .btn-reset {
      padding: 10px 20px;
      border: 1.5px solid var(--border);
      border-radius: 10px;
      background: var(--white);
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-reset:hover { background: var(--bg); }
    .btn-save {
      padding: 10px 24px;
      border: none;
      border-radius: 10px;
      background: var(--text-primary);
      font-size: 14px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-save:hover { background: #2D3748; }

    /* ============ CHART MODAL ============ */
    .chart-modal {
      background: var(--white);
      border-radius: 16px;
      padding: 28px 32px 24px;
      width: 860px;
      max-width: 95vw;
      max-height: 90vh;
      box-shadow: 0 20px 60px rgba(0,0,0,0.18);
      display: flex;
      flex-direction: column;
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .chart-header h2 {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .chart-header h2 span {
      color: var(--primary);
    }
    .chart-actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .chart-action-btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 6px 12px;
      border: 1.5px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--white);
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
      font-family: inherit;
    }
    .chart-action-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
      background: var(--primary-light);
    }
    .export-dropdown { position: relative; }
    .export-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 18px;
      border: none;
      border-radius: 8px;
      background: var(--text-primary);
      font-size: 13px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.15s;
      font-family: inherit;
    }
    .export-toggle:hover { background: #334155; }
    .export-menu {
      display: none;
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      min-width: 190px;
      background: var(--white);
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.14);
      z-index: 10;
      overflow: hidden;
    }
    .export-menu.show { display: block; }
    .export-item {
      padding: 14px 20px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.12s;
      border-bottom: 1px solid #F1F5F9;
    }
    .export-item:last-child { border-bottom: none; }
    .export-item:hover { background: var(--bg); }
    .chart-body {
      flex: 1;
      position: relative;
      min-height: 340px;
    }
    .chart-body canvas {
      width: 100% !important;
    }
    .chart-zoom-hint {
      text-align: center;
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* ============ ERROR TOAST ============ */
    #error-toast {
      display: none;
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: #FEF2F2;
      border: 1px solid var(--bad-border);
      color: var(--bad-text);
      padding: 14px 20px;
      border-radius: var(--radius);
      font-size: 13px;
      font-weight: 500;
      z-index: 2000;
      box-shadow: var(--shadow-lg);
      max-width: 400px;
    }
    #error-toast.show { display: block; }

    /* ============ CELL CYCLE SUMMARY ============ */
    #ccs-area {
      background: var(--white);
      border-radius: var(--radius);
      margin: 16px 20px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    #ccs-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 20px;
      border-bottom: 1px solid var(--border);
      background: #FAFBFC;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 20;
    }
    #ccs-table-container {
      overflow: auto;
      max-height: calc(100vh - 310px);
      position: relative;
    }
    #ccs-table {
      width: max-content;
      min-width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 12px;
    }
    #ccs-table thead th {
      position: sticky;
      top: 0;
      z-index: 12;
      background: #1E3A5F;
      color: #FFFFFF;
      font-weight: 600;
      font-size: 11px;
      padding: 10px 10px;
      text-align: center;
      white-space: nowrap;
      line-height: 1.4;
      border-bottom: 2px solid #14304F;
      border-right: 1px solid #2D5F8A;
      vertical-align: middle;
    }
    #ccs-table thead th.ccs-frozen {
      position: sticky;
      z-index: 15;
      background: #1E3A5F;
    }
    #ccs-table thead th.ccs-frozen-last {
      border-right: 2px solid #0F2740;
      box-shadow: 3px 0 6px rgba(0,0,0,0.15);
    }
    #ccs-table tbody td {
      padding: 8px 10px;
      text-align: center;
      border-bottom: 1px solid #E2E8F0;
      border-right: 1px solid #E2E8F0;
      font-size: 12px;
      color: var(--text-primary);
      white-space: nowrap;
    }
    #ccs-table tbody tr { background: #fff; }
    #ccs-table tbody tr:nth-child(even) { background: #F8FAFC; }
    #ccs-table tbody tr.ccs-data-row { cursor: pointer; transition: background 0.15s; }
    #ccs-table tbody tr.ccs-data-row:hover { background: #DBEAFE !important; }
    #ccs-table tbody tr.ccs-data-row.ccs-row-expanded { background: #E0F2FE !important; font-weight: 600; }
    #ccs-table tbody td.ccs-frozen {
      position: sticky;
      z-index: 4;
      background: inherit;
    }
    #ccs-table tbody td.ccs-frozen-last {
      border-right: 2px solid #CBD5E1;
      box-shadow: 3px 0 6px rgba(0,0,0,0.06);
    }

    .ccs-detail-row > td { padding: 0 !important; border: none !important; background: #F8FAFD !important; }
    .ccs-detail-wrap {
      margin: 8px 24px 14px 40px; border: 1px solid #CBD5E1; border-radius: 10px;
      overflow: hidden; background: #fff; box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    }
    .ccs-detail-wrap .ccs-sub-header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 10px 16px; background: linear-gradient(135deg, #1E3A5F 0%, #2D5F8A 100%); font-size: 12px;
    }
    .ccs-detail-wrap .ccs-sub-header strong { color: #fff; }
    .ccs-sub-table-wrap {
      max-height: 340px; overflow-y: auto; overflow-x: auto;
    }
    .ccs-sub-table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 11.5px;
      border: 1px solid #94A3B8;
    }
    .ccs-sub-table thead th {
      position: sticky; top: 0; z-index: 3;
      background: #F1F5F9; color: #334155; font-weight: 600; padding: 9px 12px;
      text-align: center; white-space: nowrap; font-size: 11.5px;
      letter-spacing: 0.02em;
      border-right: 1px solid #94A3B8;
      border-bottom: 2px solid #94A3B8;
    }
    .ccs-sub-table thead th:last-child { border-right: none; }
    .ccs-sub-table tbody td {
      padding: 8px 12px; text-align: center;
      font-size: 11.5px; color: #334155; white-space: nowrap;
      border-right: 1px solid #CBD5E1;
      border-bottom: 1px solid #CBD5E1;
    }
    .ccs-sub-table tbody td:last-child { border-right: none; }
    .ccs-sub-table tbody tr:last-child td { border-bottom: none; }
    .ccs-sub-table tbody tr { background: #fff; transition: background 0.12s; }
    .ccs-sub-table tbody tr:nth-child(even) { background: #FAFBFC; }
    .ccs-sub-table tbody tr:hover { background: #EFF6FF; }
    .ccs-sub-table td.status-good {
      color: #16A34A; font-weight: 700; background: #F0FDF4;
    }
    .ccs-sub-table td.status-bad {
      color: #DC2626; font-weight: 700; background: #FEF2F2;
    }
    .ccs-sub-export-btn {
      display: inline-flex; align-items: center; gap: 5px;
      padding: 5px 14px; background: rgba(255,255,255,0.15); color: #fff;
      border: 1px solid rgba(255,255,255,0.3); border-radius: 6px;
      font-size: 11.5px; font-weight: 500; cursor: pointer; transition: all 0.15s;
    }
    .ccs-sub-export-btn:hover { background: rgba(255,255,255,0.25); }
    .ccs-sub-pagination {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px 16px; border-top: 1px solid #E2E8F0; font-size: 11.5px; color: #64748B; background: #F8FAFC;
    }
    .ccs-sub-pagination select {
      padding: 3px 8px; border: 1px solid #CBD5E1; border-radius: 4px; font-size: 11px; cursor: pointer; background: #fff;
    }
    .ccs-sub-pagination button {
      background: #fff; border: 1px solid #CBD5E1; border-radius: 4px; padding: 3px 10px;
      cursor: pointer; font-size: 12px; color: #334155; transition: all 0.15s;
    }
    .ccs-sub-pagination button:hover:not(:disabled) { background: #1E3A5F; color: #fff; border-color: #1E3A5F; }
    .ccs-sub-pagination button:disabled { opacity: 0.4; cursor: not-allowed; }
    .ccs-sub-loading { padding: 20px; text-align: center; color: #64748B; font-size: 12px; }
    #ccs-table td.ce-excellent { background: #DCFCE7; color: #16A34A; font-weight: 700; }
    #ccs-table td.ce-good { background: #FFF7ED; color: #EA580C; font-weight: 700; }
    #ccs-table td.ce-bad { background: #FEF2F2; color: #DC2626; font-weight: 700; }
    #ccs-table td.rej-excellent { background: #DCFCE7; color: #16A34A; font-weight: 700; }
    #ccs-table td.rej-good { background: #FFF7ED; color: #EA580C; font-weight: 700; }
    #ccs-table td.rej-bad { background: #FEF2F2; color: #DC2626; font-weight: 700; }

    #ccs-table thead th .ccs-th-wrap {
      display: flex; align-items: center; justify-content: center; gap: 4px; cursor: default;
    }
    #ccs-table thead th .ccs-sort-btn {
      cursor: pointer; opacity: 0.6; font-size: 14px; line-height: 1; user-select: none; padding: 0 2px;
    }
    #ccs-table thead th .ccs-sort-btn:hover { opacity: 1; }
    #ccs-table thead th .ccs-sort-btn.active { opacity: 1; color: #FCD34D; }
    #ccs-table thead th .ccs-filter-btn {
      cursor: pointer; opacity: 0.6; font-size: 13px; line-height: 1; user-select: none; padding: 0 2px; position: relative;
    }
    #ccs-table thead th .ccs-filter-btn:hover { opacity: 1; }
    #ccs-table thead th .ccs-filter-btn.active { opacity: 1; color: #FCD34D; }

    .ccs-filter-popup {
      position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
      background: #fff; border: 1px solid #CBD5E1; border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18); z-index: 200; padding: 8px 0;
      min-width: 160px; max-height: 260px; overflow-y: auto;
      color: #1E293B; font-weight: 400; text-align: left;
    }
    .ccs-filter-popup .ccs-filter-search {
      width: calc(100% - 16px); margin: 0 8px 6px; padding: 5px 8px;
      border: 1px solid #CBD5E1; border-radius: 4px; font-size: 12px; outline: none;
    }
    .ccs-filter-popup .ccs-filter-search:focus { border-color: var(--primary); }
    .ccs-filter-popup label {
      display: flex; align-items: center; gap: 6px; padding: 4px 12px; font-size: 12px;
      cursor: pointer; white-space: nowrap;
    }
    .ccs-filter-popup label:hover { background: #F1F5F9; }
    .ccs-filter-popup label input { accent-color: #1E3A5F; }
    .ccs-filter-popup .ccs-filter-actions {
      display: flex; gap: 6px; padding: 6px 8px 2px; border-top: 1px solid #E2E8F0; margin-top: 4px;
    }
    .ccs-filter-popup .ccs-filter-actions button {
      flex: 1; padding: 4px 0; font-size: 11px; border-radius: 4px; cursor: pointer; border: 1px solid #CBD5E1; background: #fff;
    }
    .ccs-filter-popup .ccs-filter-actions button.apply { background: #1E3A5F; color: #fff; border-color: #1E3A5F; }

    #ccs-pagination {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      background: #FAFBFC;
      font-size: 13px;
      color: var(--text-secondary);
    }
    .ccs-page-info { font-weight: 500; }
    .ccs-page-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .ccs-page-label { font-size: 12px; color: #64748B; }
    #ccsPageSize {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      font-size: 12px;
      background: #FFF;
      cursor: pointer;
    }
    .ccs-page-btn {
      width: 30px;
      height: 30px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: #FFF;
      cursor: pointer;
      font-size: 16px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s;
    }
    .ccs-page-btn:hover { background: #EDF2F7; color: var(--primary); }
    .ccs-page-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: #F9FAFB;
    }
    .ccs-page-btn:disabled:hover {
      background: #F9FAFB;
      color: var(--text-secondary);
    }
    #ccsPageSize:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .ccs-page-num {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      min-width: 60px;
      text-align: center;
    }

    /* ============ KPI DASHBOARD ============ */
    #kpi-area {
      background: var(--white);
      margin: 0 24px 24px;
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    #kpi-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--white);
      position: relative;
      z-index: 20;
    }
    .kpi-toggle-group {
      display: flex;
      border: 1.5px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }
    .kpi-toggle-btn {
      padding: 8px 20px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      border: none;
      background: var(--white);
      color: var(--text-secondary);
      transition: all 0.2s;
      white-space: nowrap;
    }
    .kpi-toggle-btn:not(:last-child) {
      border-right: 1.5px solid var(--border);
    }
    /* Data type toggle (Cell Efficiency / Rejected Cathodes) - darker highlight */
    .kpi-toggle-btn.efficiency.active,
    .kpi-toggle-btn.rejections.active {
      background: var(--primary);
      color: var(--white);
    }
    /* Best/Worst toggle - color-coded highlight */
    .kpi-toggle-btn.best.active {
      background: #DCFCE7;
      color: #16A34A;
    }
    .kpi-toggle-btn.worst.active {
      background: #FEF2F2;
      color: #DC2626;
    }
    .kpi-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 0;
    }
    .kpi-column {
      padding: 20px 24px;
      border-right: 1px solid var(--border);
    }
    .kpi-column:last-child {
      border-right: none;
    }
    .kpi-col-title {
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 16px;
    }
    .kpi-table-header {
      display: flex;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      margin-bottom: 4px;
    }
    .kpi-table-header span {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .kpi-table-header span:first-child { width: 70px; flex-shrink: 0; }
    .kpi-table-header span.kpi-hdr-eff { flex: 1; text-align: center; }
    .kpi-table-header span:last-child { width: 50px; text-align: right; }
    .kpi-row {
      display: flex;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #F8FAFC;
    }
    .kpi-cell-label {
      width: 70px;
      flex-shrink: 0;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .kpi-bar-wrap {
      flex: 1;
      height: 20px;
      background: #F1F5F9;
      border-radius: 4px;
      overflow: hidden;
      margin: 0 10px;
    }
    .kpi-bar {
      height: 100%;
      border-radius: 4px;
      transition: width 0.6s ease;
    }
    .kpi-bar.bar-excellent { background: #16A34A; }
    .kpi-bar.bar-good { background: #EA580C; }
    .kpi-bar.bar-bad { background: #DC2626; }
    .kpi-pct {
      width: 50px;
      text-align: right;
      font-size: 13px;
      font-weight: 700;
      flex-shrink: 0;
    }
    .kpi-pct.pct-excellent { color: #16A34A; }
    .kpi-pct.pct-good { color: #EA580C; }
    .kpi-pct.pct-bad { color: #DC2626; }
    .kpi-nodata {
      text-align: center;
      padding: 40px 0;
      color: var(--text-muted);
      font-size: 13px;
    }
  </style>
</head>
<body>

  <!-- HEADER -->
  <header id="main-header">
    <div class="logo-section">
      <img src="HZL_Logo.png" alt="Hindustan Zinc Limited">
    </div>
    <div class="title-section">
      <h1>Cell Efficiency Monitoring</h1>
    </div>
    <div class="actions-section">
      <button class="settings-btn" id="settingsBtn" title="Settings">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="3"/>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/>
        </svg>
      </button>
    </div>
  </header>

  <!-- MAIN NAVIGATION -->
  <div id="sub-nav">
    <div class="sub-nav-tab active" onclick="switchDashboard('heatmap')">Cell Efficiency Heatmap</div>
    <div class="sub-nav-tab" onclick="switchDashboard('kpi')">KPI Dashboard</div>
    <div class="sub-nav-tab" onclick="switchDashboard('rejection')">Rejected Cathode Count</div>
    <div class="sub-nav-tab" onclick="switchDashboard('ccs')">Cell Cycle Summary</div>
  </div>

  <!-- SIDE TABS -->
  <div id="side-tabs">
    <div class="side-tab active" data-side="east" onclick="switchSide('east')">East Side - CSM 2</div>
    <div class="side-tab" data-side="west" onclick="switchSide('west')">West Side</div>
  </div>

  <!-- MAIN CONTENT: HEATMAP -->
  <div id="content-area">
    <!-- CONTROLS BAR -->
    <div id="controls-bar">
      <!-- Dropdown 1: Cycle Type -->
      <div class="custom-dropdown" id="dd-cycle">
        <button class="dropdown-toggle" onclick="toggleDropdown('dd-cycle')">
          <span class="dropdown-label">Individual Cycle</span>
          <span class="dropdown-chevron">&#9662;</span>
        </button>
        <div class="dropdown-menu">
          <div class="dropdown-item active" data-value="individual" onclick="selectDropdown('dd-cycle', this)">Individual Cycle</div>
          <div class="dropdown-item" data-value="moving_avg" onclick="selectDropdown('dd-cycle', this)">Last 3 Cycle Moving Average</div>
        </div>
      </div>

      <!-- Dropdown 2: Efficiency Type -->
      <div class="custom-dropdown" id="dd-efficiency">
        <button class="dropdown-toggle" onclick="toggleDropdown('dd-efficiency')">
          <span class="dropdown-label">C1/C2 Efficiency</span>
          <span class="dropdown-chevron">&#9662;</span>
        </button>
        <div class="dropdown-menu">
          <div class="dropdown-item active" data-value="c1c2" onclick="selectDropdown('dd-efficiency', this)">C1/C2 Efficiency</div>
          <div class="dropdown-item" data-value="combined" onclick="selectDropdown('dd-efficiency', this)">Combined Efficiency</div>
        </div>
      </div>

      <!-- Dropdown 3: Time Period -->
      <div class="custom-dropdown" id="dd-time">
        <button class="dropdown-toggle" onclick="toggleDropdown('dd-time')">
          <span class="dropdown-label">Last 15 Days</span>
          <span class="dropdown-chevron">&#9662;</span>
        </button>
        <div class="dropdown-menu">
          <div class="dropdown-item active" data-value="last15" onclick="selectDropdown('dd-time', this)">Last 15 Days</div>
          <div class="dropdown-item" data-value="thisMonth" onclick="selectDropdown('dd-time', this)">This Month</div>
          <div class="dropdown-item" data-value="lastMonth" onclick="selectDropdown('dd-time', this)">Last Month</div>
          <div class="dropdown-item" data-value="custom" onclick="selectDropdown('dd-time', this)">Custom</div>
        </div>
      </div>

      <!-- Custom Date Range -->
      <div id="custom-date-range">
        <span class="date-label">From</span>
        <input type="date" id="customStartDate">
        <span class="date-label">To</span>
        <input type="date" id="customEndDate">
        <button class="apply-btn" onclick="applyCustomDates()">Apply</button>
      </div>

      <!-- Moving Average Non-Productive Days Toggle (visible only in moving_avg mode) -->
      <button class="ma-toggle-btn" id="maToggleBtn" style="display:none;" onclick="toggleNonProductiveDays()" title="Toggle non-productive days display">
        <span id="maToggleIcon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="9 11 12 14 22 4"></polyline>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
          </svg>
        </span>
        <span id="maToggleLabel">Show Non-Productive Days</span>
      </button>

      <!-- Right side controls: Settings + Export -->
      <div style="margin-left:auto; display:flex; align-items:center; gap:12px;">
        <!-- Rejection Settings Button (visible only in rejection mode) -->
        <button class="rej-settings-btn" id="rejSettingsBtn" style="display:none;" onclick="openRejSettingsModal()" title="Rejection Count Settings">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
          Settings
        </button>
        <!-- Export Table Button -->
        <div class="export-dropdown" id="tableExportDropdown">
          <button class="export-toggle" onclick="toggleTableExportMenu()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Export
          </button>
          <div class="export-menu" id="tableExportMenu">
            <div class="export-item" onclick="exportTableCSV()">Download as Excel</div>
            <div class="export-item" onclick="exportTablePDF()">Download as PDF</div>
            <div class="export-item" onclick="exportTableImage()">Download as Image</div>
          </div>
        </div>
      </div>
    </div>

    <!-- TABLE -->
    <div id="table-container">
      <table id="heatmap-table">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <!-- KPI DASHBOARD -->
  <div id="kpi-area" style="display:none;">
    <div id="kpi-controls">
      <div class="kpi-toggle-group">
        <button class="kpi-toggle-btn active efficiency" onclick="switchKpiDataType('efficiency')">Cell Efficiency</button>
        <button class="kpi-toggle-btn rejections" onclick="switchKpiDataType('rejections')">Rejected Cathodes</button>
      </div>
      <div class="kpi-toggle-group" style="margin-left:16px;">
        <button class="kpi-toggle-btn active best" onclick="switchKpiMode('best')">Top 10 Best</button>
        <button class="kpi-toggle-btn worst" onclick="switchKpiMode('worst')">Top 10 Worst</button>
      </div>
      <div style="margin-left:auto;">
        <div class="export-dropdown" id="kpiExportDropdown">
          <button class="export-toggle" onclick="toggleKpiExportMenu()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Export
          </button>
          <div class="export-menu" id="kpiExportMenu">
            <div class="export-item" onclick="exportKpiExcel()">Download as Excel</div>
            <div class="export-item" onclick="exportKpiPDF()">Download as PDF</div>
            <div class="export-item" onclick="exportKpiImage()">Download as Image</div>
          </div>
        </div>
      </div>
    </div>
    <div id="kpi-loading" style="display:none;text-align:center;padding:40px;color:#64748B;font-size:14px;">
      <div class="spinner" style="margin:0 auto 12px;"></div>
      <span>Loading...</span>
    </div>
    <div id="kpi-content" class="kpi-grid">
      <div class="kpi-column">
        <h3 class="kpi-col-title">Last 3 Cycles Avg Efficiency</h3>
        <div class="kpi-table-header"><span>Cell No</span><span class="kpi-hdr-eff">Avg Efficiency</span><span>CE%</span></div>
        <div id="kpi-col-3" class="kpi-rows"></div>
      </div>
      <div class="kpi-column">
        <h3 class="kpi-col-title">Last 7 Cycles Avg Efficiency</h3>
        <div class="kpi-table-header"><span>Cell No</span><span class="kpi-hdr-eff">Avg Efficiency</span><span>CE%</span></div>
        <div id="kpi-col-7" class="kpi-rows"></div>
      </div>
      <div class="kpi-column">
        <h3 class="kpi-col-title">Last 30 Cycles Avg Efficiency</h3>
        <div class="kpi-table-header"><span>Cell No</span><span class="kpi-hdr-eff">Avg Efficiency</span><span>CE%</span></div>
        <div id="kpi-col-30" class="kpi-rows"></div>
      </div>
    </div>
  </div>

  <!-- CELL CYCLE SUMMARY DASHBOARD -->
  <div id="ccs-area" style="display:none;">
    <div id="ccs-controls">
      <div class="custom-dropdown" id="dd-ccs-time">
        <button class="dropdown-toggle" onclick="toggleDropdown('dd-ccs-time')">
          <span class="dropdown-label">This Week</span>
          <span class="dropdown-chevron">&#9662;</span>
        </button>
        <div class="dropdown-menu">
          <div class="dropdown-item active" data-value="thisWeek" onclick="selectCcsTime(this)">This Week</div>
          <div class="dropdown-item" data-value="lastWeek" onclick="selectCcsTime(this)">Last Week</div>
          <div class="dropdown-item" data-value="thisMonth" onclick="selectCcsTime(this)">This Month</div>
          <div class="dropdown-item" data-value="lastMonth" onclick="selectCcsTime(this)">Last Month</div>
          <div class="dropdown-item" data-value="custom" onclick="selectCcsTime(this)">Custom</div>
        </div>
      </div>
      <div id="ccs-custom-date-range" style="display:none;">
        <span class="date-label">From</span>
        <input type="date" id="ccsCustomStart">
        <span class="date-label">To</span>
        <input type="date" id="ccsCustomEnd">
        <button class="apply-btn" onclick="applyCcsCustomDates()">Apply</button>
      </div>
      <div style="margin-left:auto; display:flex; align-items:center; gap:12px;">
        <!-- Cold Spot Settings Button -->
        <button class="rej-settings-btn" onclick="openColdSpotSettings()" title="Cold Spot Configuration">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
          Settings
        </button>
        <div class="export-dropdown" id="ccsExportDropdown">
          <button class="export-toggle" onclick="toggleCcsExportMenu()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Export
          </button>
          <div class="export-menu" id="ccsExportMenu">
            <div class="export-item" onclick="exportCcsExcel()">Download as Excel</div>
            <div class="export-item" onclick="exportCcsPDF()">Download as PDF</div>
          </div>
        </div>
      </div>
    </div>
    <div id="ccs-loading" style="display:none;text-align:center;padding:40px;color:#64748B;font-size:14px;">
      <div class="spinner" style="margin:0 auto 12px;"></div>
      <span id="ccs-loading-text">Loading...</span>
    </div>
    <div id="ccs-table-container">
      <table id="ccs-table">
        <thead>
          <tr id="ccs-header"></tr>
        </thead>
        <tbody id="ccs-body"></tbody>
      </table>
    </div>
    <div id="ccs-pagination">
      <div class="ccs-page-info">
        <span id="ccsPageInfo">Showing 0 of 0</span>
        <span id="ccsPageLoadingIndicator" style="display:none;margin-left:10px;color:var(--primary);font-size:12px;">
          <span class="spinner-small"></span> Loading...
        </span>
      </div>
      <div class="ccs-page-controls">
        <span class="ccs-page-label">Rows per page:</span>
        <select id="ccsPageSize" onchange="ccsChangePageSize()">
          <option value="25">25</option>
          <option value="50" selected>50</option>
          <option value="100">100</option>
          <option value="200">200</option>
          <option value="500">500</option>
        </select>
        <button class="ccs-page-btn" onclick="ccsGoPage('first')" title="First">&#171;</button>
        <button class="ccs-page-btn" onclick="ccsGoPage('prev')" title="Previous">&#8249;</button>
        <span class="ccs-page-num" id="ccsPageNum">1 / 1</span>
        <button class="ccs-page-btn" onclick="ccsGoPage('next')" title="Next">&#8250;</button>
        <button class="ccs-page-btn" onclick="ccsGoPage('last')" title="Last">&#187;</button>
      </div>
    </div>
  </div>

  <!-- LOADING OVERLAY -->
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="loading-text">Loading...</div>
  </div>

  <!-- COLD SPOT SETTINGS MODAL -->
  <div class="modal-overlay" id="cold-spot-settings-modal">
    <div class="settings-modal" style="max-width:500px;">
      <div class="settings-header">
        <h2>Cold Spot Cathodes Settings</h2>
        <button class="close-btn" onclick="closeColdSpotSettings()">&times;</button>
      </div>

      <!-- Cold Spot Cathodes -->
      <div class="setting-row" style="background:#FFFFFF;border:1px solid #E2E8F0;border-radius:8px;padding:16px 20px;display:flex;align-items:center;justify-content:space-between;">
        <span style="font-weight:600;color:#1A202C;font-size:14px;">Cold Spot Cathodes</span>
        <div style="display:flex;align-items:center;gap:8px;">
          <span style="color:#64748B;font-size:13px;">Weight &lt;</span>
          <input type="number" class="setting-input" id="coldSpotInput" value="90" min="0" style="width:80px;padding:8px 12px;border:1px solid #CBD5E1;border-radius:6px;font-size:14px;text-align:center;">
          <span style="color:#64748B;font-size:13px;">kg</span>
        </div>
      </div>

      <!-- Single Side Cold -->
      <div class="setting-row" style="background:#FFFFFF;border:1px solid #E2E8F0;border-radius:8px;padding:16px 20px;display:flex;align-items:center;justify-content:space-between;">
        <span style="font-weight:600;color:#1A202C;font-size:14px;">Single Side Cold</span>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:nowrap;">
          <input type="number" class="setting-input" id="singleSideMinInput" value="60" min="0" style="width:70px;padding:8px 12px;border:1px solid #CBD5E1;border-radius:6px;font-size:14px;text-align:center;">
          <span style="color:#64748B;font-size:13px;white-space:nowrap;">&lt; Weight </span>
          <input type="number" class="setting-input" id="singleSideMaxInput" value="90" min="0" style="width:70px;padding:8px 12px;border:1px solid #CBD5E1;border-radius:6px;font-size:14px;text-align:center;">
          <span style="color:#64748B;font-size:13px;">kg</span>
        </div>
      </div>

      <!-- Double Side Cold -->
      <div class="setting-row" style="background:#FFFFFF;border:1px solid #E2E8F0;border-radius:8px;padding:16px 20px;display:flex;align-items:center;justify-content:space-between;">
        <span style="font-weight:600;color:#1A202C;font-size:14px;">Double Side Cold</span>
        <div style="display:flex;align-items:center;gap:8px;">
          <span style="color:#64748B;font-size:13px;">Weight </span>
          <input type="number" class="setting-input" id="doubleSideInput" value="60" min="0" style="width:80px;padding:8px 12px;border:1px solid #CBD5E1;border-radius:6px;font-size:14px;text-align:center;">
          <span style="color:#64748B;font-size:13px;">kg</span>
        </div>
      </div>

      <!-- Message Area -->
      <div id="coldSpotConfigMessage" style="font-size:12px;padding:10px;margin-top:12px;border-radius:6px;display:none;"></div>

      <div class="settings-buttons">
        <button class="btn-reset" onclick="resetColdSpotDefaults()">Reset Defaults</button>
        <button class="btn-save" onclick="applyColdSpotConfig()">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- PASSWORD MODAL -->
  <div class="modal-overlay" id="password-modal">
    <div class="password-modal">
      <div class="lock-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="#1A202C" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
          <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
          <circle cx="12" cy="16" r="1.5" fill="#1A202C" stroke="none"/>
        </svg>
      </div>
      <h2>Enter Passcode</h2>
      <p class="subtitle">Enter the passcode to access Dashboard Settings</p>
      <input type="password" class="passcode-input" id="passcodeInput" placeholder="Enter passcode" onkeydown="if(event.key==='Enter')unlockSettings()">
      <div class="modal-buttons">
        <button class="btn-cancel" onclick="closePasswordModal()">Cancel</button>
        <button class="btn-unlock" onclick="unlockSettings()">Unlock</button>
      </div>
    </div>
  </div>

  <!-- SETTINGS MODAL -->
  <div class="modal-overlay" id="settings-modal">
    <div class="settings-modal">
      <div class="settings-header">
        <h2>Percentage Settings</h2>
        <button class="close-btn" onclick="closeSettingsModal()">&times;</button>
      </div>

      <div class="setting-row excellent">
        <div class="setting-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg>
        </div>
        <span class="setting-label">Excellent</span>
        <div class="setting-inputs">
          <span class="input-label">Min (%)</span>
          <input type="number" class="setting-input" id="excellentMin" value="90">
          <span class="input-label">Max (%)</span>
          <input type="number" class="setting-input" id="excellentMax" value="100">
        </div>
      </div>

      <div class="setting-row good">
        <div class="setting-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <span class="setting-label">Good</span>
        <div class="setting-inputs">
          <span class="input-label">Min (%)</span>
          <input type="number" class="setting-input" id="goodMin" value="50">
          <span class="input-label">Max (%)</span>
          <input type="number" class="setting-input" id="goodMax" value="89">
        </div>
      </div>

      <div class="setting-row bad">
        <div class="setting-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/></svg>
        </div>
        <span class="setting-label">Bad</span>
        <div class="setting-inputs">
          <span class="input-label">Min (%)</span>
          <input type="number" class="setting-input" id="badMin" value="0">
          <span class="input-label">Max (%)</span>
          <input type="number" class="setting-input" id="badMax" value="49">
        </div>
      </div>

      <div class="range-preview">
        <div class="range-preview-label">Range Preview</div>
        <div class="range-bar" id="rangeBar">
          <div class="range-segment range-bad" id="rangeBad" style="flex:50">< 50</div>
          <div class="range-segment range-good" id="rangeGood" style="flex:40">50 - 90</div>
          <div class="range-segment range-excellent" id="rangeExcellent" style="flex:10">90 <</div>
        </div>
      </div>

      <div class="settings-buttons">
        <button class="btn-reset" onclick="resetDefaults()">Reset Defaults</button>
        <button class="btn-save" onclick="saveSettings()">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- REJECTION SETTINGS MODAL -->
  <div class="modal-overlay" id="rej-settings-modal">
    <div class="settings-modal" style="max-width:420px;">
      <div class="settings-header">
        <h2>Rejection Count Settings</h2>
        <button class="close-btn" onclick="closeRejSettingsModal()">&times;</button>
      </div>

      <div class="setting-row excellent">
        <div class="setting-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg>
        </div>
        <span class="setting-label">Excellent (Green)</span>
        <div class="setting-inputs">
          <span class="input-label">Count &le;</span>
          <input type="number" class="setting-input" id="rejExcellentMax" value="0" min="0">
        </div>
      </div>

      <div class="setting-row good">
        <div class="setting-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <span class="setting-label">Good (Orange)</span>
        <div class="setting-inputs">
          <span class="input-label">Count &le;</span>
          <input type="number" class="setting-input" id="rejGoodMax" value="2" min="0">
        </div>
      </div>

      <div class="setting-row bad">
        <div class="setting-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/></svg>
        </div>
        <span class="setting-label">Bad (Red)</span>
        <div class="setting-inputs">
          <span class="input-label">Count &gt;</span>
          <span style="font-weight:600;color:#94A3B8;" id="rejBadLabel">2</span>
        </div>
      </div>

      <div class="range-preview">
        <div class="range-preview-label">Threshold Preview</div>
        <div class="range-bar" id="rejRangeBar">
          <div class="range-segment range-excellent" id="rejRangeExcellent" style="flex:1">0</div>
          <div class="range-segment range-good" id="rejRangeGood" style="flex:2">1 - 2</div>
          <div class="range-segment range-bad" id="rejRangeBad" style="flex:3">3+</div>
        </div>
      </div>

      <div class="settings-buttons">
        <button class="btn-reset" onclick="resetRejDefaults()">Reset Defaults</button>
        <button class="btn-save" onclick="saveRejSettings()">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- CHART MODAL -->
  <div class="modal-overlay" id="chart-modal">
    <div class="chart-modal">
      <div class="chart-header">
        <h2 id="chart-title">Cell Efficiency - <span>Cell No 67</span></h2>
        <div class="chart-actions">
          <div class="export-dropdown" id="exportDropdown">
            <button class="export-toggle" onclick="toggleExportMenu()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
              Export
            </button>
            <div class="export-menu" id="exportMenu">
              <div class="export-item" onclick="downloadChartExcel()">Download Excel</div>
              <div class="export-item" onclick="downloadChartImage()">Download as Image</div>
            </div>
          </div>
          <button class="chart-action-btn" id="resetZoomBtn" onclick="resetChartZoom()" style="display:none;" title="Reset Zoom">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/><polyline points="1 4 1 10 7 10"/></svg>
            Reset Zoom
          </button>
          <button class="close-btn" onclick="closeChartModal()" style="font-size:28px;color:#94A3B8;">&times;</button>
        </div>
      </div>
      <div class="chart-body">
        <canvas id="cellChart"></canvas>
      </div>
    </div>
  </div>

  <!-- ERROR TOAST -->
  <div id="error-toast"></div>

  <script>
    /* ================================================
       CONFIGURATION
       ================================================ */
    const CONFIG = {
      apiBase: 'https://connector.iosense.io/api',
      origin: 'https://iosense.io',
      settingsPassword: 'hzl',
      concurrency: 6,
      eastCells: { start: 67, end: 132 },
      westCells: { start: 1, end: 66 },
      sensorC1: 'D5',
      sensorC2: 'D11'
    };

    const DASH_CONFIGS = {
      efficiency: {
        sensorC1: 'D5', sensorC2: 'D11',
        avgLabel: 'Avg Cell Efficiency',
        distLabel: 'CE Distribution',
        excellentLabel: 'Excellent Cycle',
        showPercent: true,
        chartYLabel: 'Cell Efficiency (%)',
        c1Legend: 'C1 Efficiency',
        c2Legend: 'C2 Efficiency',
        rejectionMode: false,
        rejThresholds: null
      },
      rejection: {
        sensorC1: 'D1', sensorC2: 'D7',
        avgLabel: 'Avg Rejection Count',
        distLabel: 'RC Distribution',
        excellentLabel: 'Zero Rejection',
        showPercent: false,
        chartYLabel: 'Rejection Count',
        c1Legend: 'No of Rejected Cathodes - C1',
        c2Legend: 'No of Rejected Cathodes - C2',
        rejectionMode: true,
        rejThresholds: { excellent: 0, good: 2 }
      }
    };
    let activeDashConfig = DASH_CONFIGS.efficiency;

    /* ================================================
       STATE
       ================================================ */
    const state = {
      authToken: null,
      currentSide: 'east',
      cycleType: 'individual',
      efficiencyType: 'c1c2',
      timePeriod: 'last15',
      customStart: null,
      customEnd: null,
      devices: [],
      deviceMap: {},
      cellData: {},
      rejectionData: {},
      thresholds: {
        excellent: { min: 90, max: 100 },
        good: { min: 50, max: 89 },
        bad: { min: 0, max: 49 }
      },
      rejThresholds: {
        excellent: 0,
        good: 2
      },
      showDashForNonProductive: false
    };

    /* ================================================
       HELPERS
       ================================================ */
    function showLoading(text) {
      document.getElementById('loading-text').textContent = text || 'Loading...';
      document.getElementById('loading-overlay').classList.add('show');
    }
    function hideLoading() {
      document.getElementById('loading-overlay').classList.remove('show');
    }
    function showError(msg) {
      const t = document.getElementById('error-toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 5000);
    }

    function getDateRange() {
      const now = new Date();
      let start, end;
      if (currentDashboard === 'kpi') {
        end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
        start = new Date(end);
        start.setDate(start.getDate() - 44);
        start.setHours(0, 0, 0, 0);
        return { start, end };
      }
      switch (state.timePeriod) {
        case 'last15':
          end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
          start = new Date(end);
          start.setDate(start.getDate() - 14);
          start.setHours(0, 0, 0, 0);
          break;
        case 'thisMonth':
          start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0);
          end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
          break;
        case 'lastMonth':
          start = new Date(now.getFullYear(), now.getMonth() - 1, 1, 0, 0, 0, 0);
          end = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
          break;
        case 'custom':
          start = state.customStart ? new Date(state.customStart + 'T00:00:00') : new Date(now - 15 * 86400000);
          end = state.customEnd ? new Date(state.customEnd + 'T23:59:59.999') : now;
          break;
      }
      return { start, end };
    }

    function getDatesArray(start, end) {
      const dates = [];
      const d = new Date(start);
      d.setHours(0, 0, 0, 0);
      const endDate = new Date(end);
      endDate.setHours(0, 0, 0, 0);
      while (d <= endDate) {
        dates.push(new Date(d));
        d.setDate(d.getDate() + 1);
      }
      return dates;
    }

    function formatDateHeader(d) {
      return String(d.getDate()).padStart(2, '0') + ' ' + d.toLocaleString('en', { month: 'short' });
    }

    function formatDateKey(d) {
      return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
    }

    // Helper function to format duration for exports
    function getFormattedDuration(dashboardType) {
      const now = new Date();
      let periodLabel = '';
      let startDate, endDate;

      // Handle different dashboard types
      if (dashboardType === 'heatmap' || dashboardType === 'rejection') {
        // Cell Efficiency Heatmap and Rejection Count use state.timePeriod
        const { start, end } = getDateRange();
        startDate = start;
        endDate = end;

        switch (state.timePeriod) {
          case 'last15': periodLabel = 'Last 15 Days'; break;
          case 'thisMonth': periodLabel = 'This Month'; break;
          case 'lastMonth': periodLabel = 'Last Month'; break;
          case 'custom': periodLabel = 'Custom Period'; break;
          default: periodLabel = 'Last 15 Days';
        }
      } else if (dashboardType === 'ccs') {
        // Cell Cycle Summary uses ccsState.timePeriod
        const { start, end } = getCcsDateRange();
        startDate = start;
        endDate = end;

        switch (ccsState.timePeriod) {
          case 'thisWeek': periodLabel = 'This Week'; break;
          case 'lastWeek': periodLabel = 'Last Week'; break;
          case 'thisMonth': periodLabel = 'This Month'; break;
          case 'lastMonth': periodLabel = 'Last Month'; break;
          case 'custom': periodLabel = 'Custom Period'; break;
          default: periodLabel = 'This Week';
        }
      } else if (dashboardType === 'kpi') {
        // KPI Dashboard - default to last 30 days
        endDate = new Date();
        startDate = new Date();
        startDate.setDate(startDate.getDate() - 29);
        startDate.setHours(0, 0, 0, 0);
        periodLabel = 'Last 30 Days';
      }

      // Format dates
      const formatDate = (d) => {
        const dd = String(d.getDate()).padStart(2, '0');
        const mon = d.toLocaleString('en-US', { month: 'short' });
        const yyyy = d.getFullYear();
        return `${dd}-${mon}-${yyyy}`;
      };

      const formatDateTime = (d) => {
        const date = formatDate(d);
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${date} ${hh}:${mm}`;
      };

      // Check if this is a current/active period
      const isCurrentPeriod = periodLabel.includes('This') || periodLabel === 'Today';

      let durationStr = '';
      if (isCurrentPeriod) {
        // For current periods, show exact time
        const actualEndTime = new Date(); // Current time of export
        durationStr = `Duration: ${periodLabel} (${formatDate(startDate)} 00:00 to ${formatDateTime(actualEndTime)})`;
      } else {
        // For past periods, just show date range
        durationStr = `Duration: ${periodLabel} (${formatDate(startDate)} to ${formatDate(endDate)})`;
      }

      return durationStr;
    }

    function getCellRange() {
      return state.currentSide === 'east' ? CONFIG.eastCells : CONFIG.westCells;
    }

    function getCellClass(value) {
      if (value === null || value === undefined || isNaN(value)) return 'cell-nodata';
      const v = parseFloat(value);
      if (activeDashConfig.rejectionMode) {
        const rt = state.rejThresholds;
        if (v <= rt.excellent) return 'cell-excellent';
        if (v <= rt.good) return 'cell-good';
        return 'cell-bad';
      }
      if (v >= state.thresholds.excellent.min) return 'cell-excellent';
      if (v >= state.thresholds.good.min) return 'cell-good';
      return 'cell-bad';
    }

    function getExcellentCycleClass(excellent, total) {
      if (total === 0) return 'cell-nodata';
      const ratio = excellent / total;
      if (ratio >= 0.7) return 'cell-excellent';
      if (ratio >= 0.4) return 'cell-good';
      return 'cell-bad';
    }

    function isExcellentValue(v) {
      if (activeDashConfig.rejectionMode) return v <= state.rejThresholds.excellent;
      return v >= state.thresholds.excellent.min;
    }
    function isGoodValue(v) {
      if (activeDashConfig.rejectionMode) {
        const rt = state.rejThresholds;
        return v > rt.excellent && v <= rt.good;
      }
      return v >= state.thresholds.good.min && v < state.thresholds.excellent.min;
    }
    function isBadValue(v) {
      if (activeDashConfig.rejectionMode) return v > state.rejThresholds.good;
      return v < state.thresholds.good.min;
    }

    function getRejDistLabels() {
      return [
        { l: 'Excellent', fn: v => isExcellentValue(v) },
        { l: 'Good', fn: v => isGoodValue(v) },
        { l: 'Bad', fn: v => isBadValue(v) }
      ];
    }

    /* ================================================
       API MODULE - Authentication
       ================================================ */

    /**
     * Validate SSO Token - IOsense SDK
     * Endpoint: GET /api/retrieve-sso-token/{token}
     * SSO tokens are ONE-TIME USE and expire after 60 seconds
     * Returns Bearer JWT token for subsequent API calls
     */
    async function validateSSOToken(token) {
      try {
        console.log(' Validating SSO Token...');
        // Remove 'Bearer ' prefix if present, as token is passed as path parameter
        const cleanToken = token.replace(/^Bearer\s+/i, '');

        const url = `${CONFIG.apiBase}/retrieve-sso-token/${cleanToken}`;
        const res = await fetch(url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'organisation': CONFIG.origin,
            'ngsw-bypass': 'true'
          }
        });

        const data = await res.json();
        console.log('SSO Token validation response:', data);

        if (data.success && data.token) {
          console.log(' SSO Token validated successfully');
          console.log('Organisation:', data.organisation, 'User ID:', data.userId);
          return {
            valid: true,
            token: data.token, // This is already a Bearer token
            organisation: data.organisation,
            userId: data.userId
          };
        } else {
          console.warn(' SSO Token validation failed:', data.errors || 'Unknown error');
          return { valid: false, error: data.errors || 'Token validation failed' };
        }
      } catch (e) {
        console.error(' Error validating SSO token:', e);
        return { valid: false, error: e.message };
      }
    }

    /**
     * API Login - Handles SSO authentication with fallbacks
     * Priority:
     * 1. Check localStorage for existing Bearer token
     * 2. Validate SSO token from URL (?token=xxx)
     * 3. Fallback to username/password
     * 4. Use hardcoded fallback auth
     */
    async function apiLogin() {
      console.log(' Starting authentication...');
      showLoading('Loading...');

      try {
        // Priority 1: Check localStorage for existing Bearer token
        const storedToken = localStorage.getItem('authToken');
        if (storedToken && storedToken.startsWith('Bearer ')) {
          console.log(' Using stored Bearer token from localStorage');
          state.authToken = storedToken;
          const userId = localStorage.getItem('userId');
          showLoading('Loading...');
          return true;
        } else {
          console.log('  No valid stored token found');
        }

        // Priority 2: Check for SSO token in URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const ssoToken = urlParams.get('token'); // IOsense uses ?token=xxx

        if (ssoToken) {
          console.log(' SSO Token found in URL');
          showLoading('Loading...');
          const validation = await validateSSOToken(ssoToken);

          if (validation.valid && validation.token) {
            // Store the Bearer JWT token returned by the API
            state.authToken = validation.token;
            localStorage.setItem('authToken', validation.token);
            localStorage.setItem('organisation', validation.organisation);
            localStorage.setItem('userId', validation.userId);

            // Clean up URL parameter (SSO tokens are one-time use)
            urlParams.delete('token');
            const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
            window.history.replaceState({}, '', newUrl);

            console.log(' Authentication successful via SSO token');
            console.log('Bearer token saved to localStorage');
            showLoading('Loading...');
            return true;
          } else {
            console.warn(' SSO token validation failed:', validation.error);
            console.warn('  Falling back to credentials login');
            showLoading('Loading...');
          }
        } else {
          console.log('  No SSO token in URL');
        }

        // Priority 3: Fallback to username/password login
        console.log(' Attempting username/password login...');
        const res = await fetch(CONFIG.apiBase + '/login', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'origin': CONFIG.origin,
            'organisation': CONFIG.origin,
            'ngsw-bypass': 'true'
          },
          body: JSON.stringify({
            username: CONFIG.username,
            password: CONFIG.password
          })
        });
        const data = await res.json();
        if (data.success && data.authorization) {
          state.authToken = data.authorization;
          console.log(' Authentication successful via credentials');
          return true;
        } else {
          console.warn(' Credentials login failed');
        }
      } catch (e) {
        console.warn(' Login error:', e);
      }

      // Priority 4: Use hardcoded fallback auth
      console.log('  Using hardcoded fallback authentication');
      state.authToken = 'Bearer ' + CONFIG.fallbackAuth;
      return true;
    }

    /**
     * Logout - Clears all authentication data
     */
    function logout() {
      console.log(' Logging out...');
      state.authToken = null;
      localStorage.removeItem('authToken');
      localStorage.removeItem('organisation');
      localStorage.removeItem('userId');
      alert('You have been logged out. Please generate a new SSO token from IOsense portal to log in again.');
      window.location.reload();
    }

    function authHeaders() {
      const authVal = state.authToken.startsWith('Bearer ') ? state.authToken : 'Bearer ' + state.authToken;
      return {
        'Content-Type': 'application/json',
        'Authorization': authVal,
        'organisation': CONFIG.origin,
        'ngsw-bypass': 'true'
      };
    }

    function buildDeviceMap() {
      const cellRange = getCellRange();
      state.deviceMap = {};
      for (let i = cellRange.start; i <= cellRange.end; i++) {
        const paddedNum = String(i).padStart(2, '0');
        state.deviceMap[i] = { devID: `HZL_Cell${paddedNum}`, devName: `Cell ${i}` };
      }
    }

    async function fetchSensorData(devID, sensor, startMs, endMs, retries = 2) {
      for (let attempt = 0; attempt <= retries; attempt++) {
        try {
          const url = `${CONFIG.apiBase}/account/deviceData/getDataCalibration/${devID}/${sensor}/${startMs}/${endMs}/true`;
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 30000);
          const res = await fetch(url, { method: 'GET', headers: authHeaders(), signal: controller.signal });
          clearTimeout(timeout);
          if (!res.ok) { if (attempt < retries) { await sleep(500); continue; } return []; }
          const data = await res.json();
          if (data.success && data.data) {
            if (Array.isArray(data.data) && data.data.length > 0) {
              return Array.isArray(data.data[0]) ? data.data[0] : data.data;
            }
          }
          return [];
        } catch (e) {
          if (attempt < retries) { await sleep(1000 * (attempt + 1)); continue; }
          console.warn(`Failed after ${retries + 1} attempts: ${devID}/${sensor}`);
        }
      }
      return [];
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function runWithConcurrency(tasks, limit) {
      const results = [];
      let idx = 0;
      async function worker() {
        while (idx < tasks.length) {
          const i = idx++;
          try {
            results[i] = await tasks[i]();
          } catch (e) {
            console.warn('Task failed:', e);
            results[i] = null;
          }
        }
      }
      const workers = Array.from({ length: Math.min(limit, tasks.length) }, () => worker());
      await Promise.all(workers);
      return results;
    }

    /* ================================================
       DATA LOADING
       ================================================ */
    async function loadData() {
      if (!state.authToken) {
        showLoading('Loading...');
        await apiLogin();
      }

      showLoading('Loading...');
      buildDeviceMap();

      const cellRange = getCellRange();
      const cellNums = Object.keys(state.deviceMap).map(Number).sort((a, b) => a - b);

      const { start, end } = getDateRange();
      const isMovingAvg = state.cycleType === 'moving_avg';
      const fetchStart = new Date(start);
      if (isMovingAvg) fetchStart.setDate(fetchStart.getDate() - 15);
      const startMs = fetchStart.getTime();
      const endMs = end.getTime();

      state.cellData = {};
      let completed = 0;
      const total = cellNums.length * 2;

      const tasks = [];
      cellNums.forEach(cellNum => {
        const dev = state.deviceMap[cellNum];
        if (!dev) return;

        tasks.push(async () => {
          const dataC1 = await fetchSensorData(dev.devID, activeDashConfig.sensorC1, startMs, endMs);
          completed++;
          showLoading(`Loading...`);
          return { cellNum, sensor: 'C1', data: dataC1 };
        });
        tasks.push(async () => {
          const dataC2 = await fetchSensorData(dev.devID, activeDashConfig.sensorC2, startMs, endMs);
          completed++;
          showLoading(`Loading...`);
          return { cellNum, sensor: 'C2', data: dataC2 };
        });
      });

      const results = await runWithConcurrency(tasks, CONFIG.concurrency);

      results.forEach(r => {
        if (!r) return;
        if (!state.cellData[r.cellNum]) state.cellData[r.cellNum] = {};
        state.cellData[r.cellNum][r.sensor] = processTimeSeries(r.data);
      });

      hideLoading();
      renderTable();
    }

    function processTimeSeries(dataPoints) {
      const byDate = {};
      if (!dataPoints || !dataPoints.length) return byDate;

      dataPoints.forEach(dp => {
        if (dp && dp.time && dp.value !== undefined && dp.value !== null) {
          const d = new Date(dp.time);
          const key = formatDateKey(d);
          const val = parseFloat(dp.value);
          if (!isNaN(val)) {
            if (!byDate[key]) {
              byDate[key] = { value: val, time: dp.time };
            } else {
              if (new Date(dp.time) > new Date(byDate[key].time)) {
                byDate[key] = { value: val, time: dp.time };
              }
            }
          }
        }
      });

      const result = {};
      Object.keys(byDate).forEach(k => {
        result[k] = Math.round(byDate[k].value * 100) / 100;
      });
      return result;
    }

    function computeMovingAvg(rawData, displayDates) {
      const allDayKeys = Object.keys(rawData).sort();
      const result = {};
      displayDates.forEach(d => {
        const dk = formatDateKey(d);
        const cycleValues = [];
        for (let i = allDayKeys.length - 1; i >= 0 && cycleValues.length < 3; i--) {
          if (allDayKeys[i] <= dk) cycleValues.push(rawData[allDayKeys[i]]);
        }
        if (cycleValues.length > 0) {
          const avg = cycleValues.reduce((a, b) => a + b, 0) / cycleValues.length;
          const hasNewCycle = rawData.hasOwnProperty(dk);
          result[dk] = { value: Math.round(avg * 100) / 100, hasNewCycle };
        }
      });
      return result;
    }

    /* ================================================
       TABLE RENDERING
       ================================================ */
    function renderTable() {
      const isCombined = state.efficiencyType === 'combined';
      const isMovAvg = state.cycleType === 'moving_avg';
      const { start, end } = getDateRange();
      const dates = getDatesArray(start, end);
      const cellRange = getCellRange();
      const cellNums = [];
      for (let i = cellRange.start; i <= cellRange.end; i++) cellNums.push(i);

      const tableContainer = document.getElementById('table-container');
      tableContainer.classList.toggle('mode-combined', isCombined);
      tableContainer.classList.toggle('mode-rejection', activeDashConfig.rejectionMode);
      tableContainer.classList.toggle('mode-moving-avg', isMovAvg);

      const thead = document.getElementById('table-header');
      const tbody = document.getElementById('table-body');

      const cfgAvgLabel = activeDashConfig.avgLabel;
      const cfgExcLabel = activeDashConfig.excellentLabel;
      const cfgDistLabel = activeDashConfig.distLabel;
      const showPct = activeDashConfig.showPercent;
      const isRej = activeDashConfig.rejectionMode;
      const showExcCol = !isCombined && !isRej && !isMovAvg;
      const showAvgCol = !isMovAvg;
      const showSummaryRows = !isMovAvg;

      let headerHTML = '<th class="col-cellno">Cell</th>';
      if (!isCombined) headerHTML += '<th class="col-selection">Selection</th>';
      dates.forEach(d => { headerHTML += `<th>${formatDateHeader(d)}</th>`; });
      if (showAvgCol) headerHTML += `<th class="col-avg">${cfgAvgLabel}</th>`;
      if (showExcCol) headerHTML += `<th class="col-excellent">${cfgExcLabel}</th>`;
      thead.innerHTML = headerHTML;

      let bodyHTML = '';
      const dateKeys = dates.map(d => formatDateKey(d));
      const allDayDataC1 = {}, allDayDataC2 = {}, allDayDataCombined = {};
      dateKeys.forEach(dk => { allDayDataC1[dk] = []; allDayDataC2[dk] = []; allDayDataCombined[dk] = []; });
      let totalExcellentAll = 0, totalCyclesAll = 0;

      // Variables for total rejection row (for rejection mode)
      let totalRowData = {};
      let totalRowLabel = isRej ? 'Total Rejection' : cfgAvgLabel;

      if (isCombined) {
        // ---- COMBINED EFFICIENCY MODE ----
        cellNums.forEach(cellNum => {
          const cellInfo = state.cellData[cellNum] || {};
          const c1Data = cellInfo['C1'] || {};
          const c2Data = cellInfo['C2'] || {};

          let maData = null;
          if (isMovAvg) {
            const combRaw = {};
            const allKeys = new Set([...Object.keys(c1Data), ...Object.keys(c2Data)]);
            allKeys.forEach(k => {
              const v1 = c1Data[k], v2 = c2Data[k];
              const vals = [v1, v2].filter(v => v !== undefined && v !== null);
              if (vals.length > 0) combRaw[k] = vals.reduce((a, b) => a + b, 0) / vals.length;
            });
            maData = computeMovingAvg(combRaw, dates);
          }

          let rowValues = [];
          let rowHTML = `<td class="col-cellno"><span class="cell-num-label" onclick="openCellChart(${cellNum})">Cell No ${cellNum}</span></td>`;
          dateKeys.forEach(dk => {
            if (isMovAvg) {
              const ma = maData ? maData[dk] : null;
              if (ma) {
                rowValues.push(ma.value);
                allDayDataCombined[dk].push(ma.value);
                if (state.showDashForNonProductive && !ma.hasNewCycle) {
                  rowHTML += `<td class="cell-nodata">--</td>`;
                } else {
                  const style = ma.hasNewCycle ? '' : 'font-style:italic;text-decoration:underline;text-underline-offset:2px;opacity:0.75;';
                  rowHTML += `<td class="${getCellClass(ma.value)}" style="${style}">${Math.round(ma.value)}</td>`;
                }
              } else { rowHTML += `<td class="cell-nodata">--</td>`; }
            } else {
              const c1 = c1Data[dk], c2 = c2Data[dk];
              const vals = [c1, c2].filter(v => v !== undefined && v !== null);
              if (vals.length > 0) {
                const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
                rowValues.push(avg);
                allDayDataCombined[dk].push(avg);
                rowHTML += `<td class="${getCellClass(avg)}">${Math.round(avg)}</td>`;
              } else { rowHTML += `<td class="cell-nodata">--</td>`; }
            }
          });
          if (showAvgCol) {
            const cellAvg = rowValues.length ? (rowValues.reduce((a, b) => a + b, 0) / rowValues.length) : null;
            rowHTML += `<td class="col-avg ${getCellClass(cellAvg)}">${cellAvg !== null ? Math.round(cellAvg) + (showPct ? '%' : '') : '--'}</td>`;
          }
          bodyHTML += `<tr class="cell-group-start">${rowHTML}</tr>`;
        });

        if (showSummaryRows) {
          // Avg/Total Row (combined) - will be inserted at top later
          let avgRowHTML = `<td class="col-cellno" style="font-size:13px;font-weight:800;"><span class="cell-num-label" onclick="openAvgChart()" style="font-size:13px;">${totalRowLabel}</span></td>`;
          let allAvgValues = [];
          let allTotalValues = [];
          dateKeys.forEach(dk => {
            const vals = allDayDataCombined[dk];
            if (vals.length > 0) {
              if (isRej) {
                // For rejection mode: calculate total (sum)
                const total = vals.reduce((a, b) => a + b, 0);
                allTotalValues.push(total);
                avgRowHTML += `<td class="${getCellClass(total)}">${Math.round(total)}</td>`;
              } else {
                // For efficiency mode: calculate average
                const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
                allAvgValues.push(avg);
                avgRowHTML += `<td class="${getCellClass(avg)}">${Math.round(avg)}${showPct ? '%' : ''}</td>`;
              }
            } else {
              avgRowHTML += `<td class="cell-nodata">--</td>`;
            }
          });

          if (isRej) {
            // For rejection mode: show total of all totals
            const grandTotal = allTotalValues.length ? allTotalValues.reduce((a, b) => a + b, 0) : null;
            avgRowHTML += `<td class="col-avg ${getCellClass(grandTotal)}">${grandTotal !== null ? Math.round(grandTotal) : '--'}</td>`;
          } else {
            // For efficiency mode: show average
            const overallAvg = allAvgValues.length ? (allAvgValues.reduce((a, b) => a + b, 0) / allAvgValues.length) : null;
            avgRowHTML += `<td class="col-avg ${getCellClass(overallAvg)}">${overallAvg !== null ? Math.round(overallAvg) + (showPct ? '%' : '') : '--'}</td>`;
          }

          totalRowData.combined = `<tr class="row-avg">${avgRowHTML}</tr>`;

          // Distribution rows (combined)
          const distLabels = activeDashConfig.rejectionMode
            ? getRejDistLabels()
            : [{l:'Excellent',fn:v=>isExcellentValue(v)},{l:'Good',fn:v=>isGoodValue(v)},{l:'Bad',fn:v=>isBadValue(v)}];
          distLabels.forEach((dl, idx) => {
            const textColor = idx === 0 ? 'var(--excellent-text)' : idx === 1 ? 'var(--good-text)' : 'var(--bad-text)';
            const colorClass = idx === 0 ? 'row-dist-excellent' : idx === 1 ? 'row-dist-good' : 'row-dist-bad';
            let distRowHTML = `<td class="col-cellno" style="font-weight:800;font-size:12px;color:${textColor};cursor:pointer;" onclick="openDistChart('${dl.l}', ${idx})"><span style="text-decoration:underline;text-underline-offset:2px;">${dl.l}</span></td>`;
            dateKeys.forEach(dk => {
              const dayVals = allDayDataCombined[dk] || [];
              if (dayVals.length === 0) {
                distRowHTML += `<td style="color:#CBD5E1;font-weight:500;">--</td>`;
              } else {
                let count = 0;
                dayVals.forEach(v => { if (dl.fn(v)) count++; });
                distRowHTML += `<td style="color:${textColor};font-weight:600;">${count}</td>`;
              }
            });
            distRowHTML += `<td class="col-avg" style="color:${textColor};font-weight:700;">--</td>`;
            bodyHTML += `<tr class="row-dist ${colorClass}">${distRowHTML}</tr>`;
          });
        }

      } else {
        // ---- C1/C2 EFFICIENCY MODE ----
        cellNums.forEach(cellNum => {
          const cellInfo = state.cellData[cellNum] || {};
          const c1Data = cellInfo['C1'] || {};
          const c2Data = cellInfo['C2'] || {};

          let maC1 = null, maC2 = null;
          if (isMovAvg) {
            maC1 = computeMovingAvg(c1Data, dates);
            maC2 = computeMovingAvg(c2Data, dates);
          }

          let c1Values = [], c1Excellent = 0, c1Total = 0;
          let c1RowHTML = `<td class="col-cellno cell-group-start" rowspan="2"><span class="cell-num-label" onclick="openCellChart(${cellNum})">Cell No ${cellNum}</span></td>`;
          c1RowHTML += `<td class="col-selection">C1</td>`;
          dateKeys.forEach(dk => {
            if (isMovAvg) {
              const ma = maC1 ? maC1[dk] : null;
              if (ma) {
                c1Values.push(ma.value);
                allDayDataC1[dk].push(ma.value);
                if (state.showDashForNonProductive && !ma.hasNewCycle) {
                  c1RowHTML += `<td class="cell-nodata">--</td>`;
                } else {
                  const style = ma.hasNewCycle ? '' : 'font-style:italic;text-decoration:underline;text-underline-offset:2px;opacity:0.75;';
                  c1RowHTML += `<td class="${getCellClass(ma.value)}" style="${style}">${Math.round(ma.value)}</td>`;
                }
              } else { c1RowHTML += `<td class="cell-nodata">--</td>`; }
            } else {
              const val = c1Data[dk];
              if (val !== undefined && val !== null) {
                c1Values.push(val); c1Total++;
                if (isExcellentValue(val)) c1Excellent++;
                allDayDataC1[dk].push(val);
                c1RowHTML += `<td class="${getCellClass(val)}">${Math.round(val)}</td>`;
              } else { c1RowHTML += `<td class="cell-nodata">--</td>`; }
            }
          });
          if (showAvgCol) {
            const c1Avg = c1Values.length ? (c1Values.reduce((a, b) => a + b, 0) / c1Values.length) : null;
            c1RowHTML += `<td class="col-avg ${getCellClass(c1Avg)}">${c1Avg !== null ? Math.round(c1Avg) + (showPct ? '%' : '') : '--'}</td>`;
          }
          if (showExcCol) c1RowHTML += `<td class="col-excellent ${getExcellentCycleClass(c1Excellent, c1Total)}">${c1Total > 0 ? c1Excellent + ' out of ' + c1Total : '--'}</td>`;
          bodyHTML += `<tr class="cell-group-start">${c1RowHTML}</tr>`;
          totalExcellentAll += c1Excellent; totalCyclesAll += c1Total;

          let c2Values = [], c2Excellent = 0, c2Total = 0;
          let c2RowHTML = `<td class="col-selection">C2</td>`;
          dateKeys.forEach(dk => {
            if (isMovAvg) {
              const ma = maC2 ? maC2[dk] : null;
              if (ma) {
                c2Values.push(ma.value);
                allDayDataC2[dk].push(ma.value);
                if (state.showDashForNonProductive && !ma.hasNewCycle) {
                  c2RowHTML += `<td class="cell-nodata">--</td>`;
                } else {
                  const style = ma.hasNewCycle ? '' : 'font-style:italic;text-decoration:underline;text-underline-offset:2px;opacity:0.75;';
                  c2RowHTML += `<td class="${getCellClass(ma.value)}" style="${style}">${Math.round(ma.value)}</td>`;
                }
              } else { c2RowHTML += `<td class="cell-nodata">--</td>`; }
            } else {
              const val = c2Data[dk];
              if (val !== undefined && val !== null) {
                c2Values.push(val); c2Total++;
                if (isExcellentValue(val)) c2Excellent++;
                allDayDataC2[dk].push(val);
                c2RowHTML += `<td class="${getCellClass(val)}">${Math.round(val)}</td>`;
              } else { c2RowHTML += `<td class="cell-nodata">--</td>`; }
            }
          });
          if (showAvgCol) {
            const c2Avg = c2Values.length ? (c2Values.reduce((a, b) => a + b, 0) / c2Values.length) : null;
            c2RowHTML += `<td class="col-avg ${getCellClass(c2Avg)}">${c2Avg !== null ? Math.round(c2Avg) + (showPct ? '%' : '') : '--'}</td>`;
          }
          if (showExcCol) c2RowHTML += `<td class="col-excellent ${getExcellentCycleClass(c2Excellent, c2Total)}">${c2Total > 0 ? c2Excellent + ' out of ' + c2Total : '--'}</td>`;
          bodyHTML += `<tr>${c2RowHTML}</tr>`;
          totalExcellentAll += c2Excellent; totalCyclesAll += c2Total;
        });

        if (showSummaryRows) {
          // Avg/Total Row (C1/C2) - will be inserted at top later
          let avgRowHTML = `<td class="col-cellno" style="font-size:13px;font-weight:800;"><span class="cell-num-label" onclick="openAvgChart()" style="font-size:13px;">${totalRowLabel}</span></td>`;
          avgRowHTML += `<td class="col-selection">--</td>`;
          let allAvgValues = [];
          let allTotalValues = [];
          dateKeys.forEach(dk => {
            const combined = [...(allDayDataC1[dk] || []), ...(allDayDataC2[dk] || [])];
            if (combined.length > 0) {
              if (isRej) {
                // For rejection mode: calculate total (sum)
                const total = combined.reduce((a, b) => a + b, 0);
                allTotalValues.push(total);
                avgRowHTML += `<td class="${getCellClass(total)}">${Math.round(total)}</td>`;
              } else {
                // For efficiency mode: calculate average
                const avg = combined.reduce((a, b) => a + b, 0) / combined.length;
                allAvgValues.push(avg);
                avgRowHTML += `<td class="${getCellClass(avg)}">${Math.round(avg)}${showPct ? '%' : ''}</td>`;
              }
            } else { avgRowHTML += `<td class="cell-nodata">--</td>`; }
          });

          if (isRej) {
            // For rejection mode: show total of all totals
            const grandTotal = allTotalValues.length ? allTotalValues.reduce((a, b) => a + b, 0) : null;
            avgRowHTML += `<td class="col-avg ${getCellClass(grandTotal)}">${grandTotal !== null ? Math.round(grandTotal) : '--'}</td>`;
          } else {
            // For efficiency mode: show average
            const overallAvg = allAvgValues.length ? (allAvgValues.reduce((a, b) => a + b, 0) / allAvgValues.length) : null;
            avgRowHTML += `<td class="col-avg ${getCellClass(overallAvg)}">${overallAvg !== null ? Math.round(overallAvg) + (showPct ? '%' : '') : '--'}</td>`;
          }

          if (showExcCol) avgRowHTML += `<td class="col-excellent ${getExcellentCycleClass(totalExcellentAll, totalCyclesAll)}">${totalCyclesAll > 0 ? totalExcellentAll + ' out of ' + totalCyclesAll : '--'}</td>`;
          totalRowData.c1c2 = `<tr class="row-avg">${avgRowHTML}</tr>`;

          // Distribution (C1/C2)
          const allDayDataAll = {};
          dateKeys.forEach(dk => { allDayDataAll[dk] = [...(allDayDataC1[dk] || []), ...(allDayDataC2[dk] || [])]; });
          const distLabelsC1C2 = isRej
            ? getRejDistLabels()
            : [{l:'Excellent',fn:v=>isExcellentValue(v)},{l:'Good',fn:v=>isGoodValue(v)},{l:'Bad',fn:v=>isBadValue(v)}];
          distLabelsC1C2.forEach((dl, li) => {
            let distRowHTML = '';
            if (li === 0) distRowHTML += `<td class="col-cellno" rowspan="3" style="font-size:12px;font-weight:800;">${cfgDistLabel}</td>`;
            const textColor = li === 0 ? 'var(--excellent-text)' : li === 1 ? 'var(--good-text)' : 'var(--bad-text)';
            const colorClass = li === 0 ? 'row-dist-excellent' : li === 1 ? 'row-dist-good' : 'row-dist-bad';
            distRowHTML += `<td class="col-selection" style="color:${textColor};font-weight:700;">${dl.l}</td>`;
            dateKeys.forEach(dk => {
              const dayVals = allDayDataAll[dk] || [];
              if (dayVals.length === 0) {
                distRowHTML += `<td style="color:#CBD5E1;font-weight:500;">--</td>`;
              } else {
                let count = 0;
                dayVals.forEach(v => { if (dl.fn(v)) count++; });
                distRowHTML += `<td style="color:${textColor};font-weight:600;">${count}</td>`;
              }
            });
            distRowHTML += `<td class="col-avg" style="color:${textColor};font-weight:700;">--</td>`;
            if (showExcCol) distRowHTML += `<td class="col-excellent">--</td>`;
            bodyHTML += `<tr class="row-dist ${colorClass}">${distRowHTML}</tr>`;
          });
        }
      }

      // Prepend total/avg row at the top if available
      if (showSummaryRows) {
        const totalRow = isCombined ? totalRowData.combined : totalRowData.c1c2;
        if (totalRow) {
          bodyHTML = totalRow + bodyHTML;
        }
      }

      tbody.innerHTML = bodyHTML;
    }

    /* ================================================
       DROPDOWN LOGIC
       ================================================ */
    function toggleDropdown(id) {
      const dd = document.getElementById(id);
      const menu = dd.querySelector('.dropdown-menu');
      const toggle = dd.querySelector('.dropdown-toggle');
      const isOpen = menu.classList.contains('show');

      closeAllDropdowns();

      if (!isOpen) {
        menu.classList.add('show');
        toggle.classList.add('open');
      }
    }

    function closeAllDropdowns() {
      document.querySelectorAll('.dropdown-menu').forEach(m => m.classList.remove('show'));
      document.querySelectorAll('.dropdown-toggle').forEach(t => t.classList.remove('open'));
    }

    function selectDropdown(ddId, item) {
      const dd = document.getElementById(ddId);
      dd.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('active'));
      item.classList.add('active');
      dd.querySelector('.dropdown-label').textContent = item.textContent;
      closeAllDropdowns();

      const value = item.dataset.value;

      if (ddId === 'dd-cycle') {
        state.cycleType = value;
        // Show/hide moving average toggle button (only for non-rejection dashboards)
        const maToggleBtn = document.getElementById('maToggleBtn');
        if (value === 'moving_avg' && !activeDashConfig.rejectionMode) {
          maToggleBtn.style.display = 'inline-flex';
        } else {
          maToggleBtn.style.display = 'none';
        }
      } else if (ddId === 'dd-efficiency') {
        state.efficiencyType = value;
        renderTable();
        return;
      } else if (ddId === 'dd-time') {
        state.timePeriod = value;
        const customRange = document.getElementById('custom-date-range');
        if (value === 'custom') {
          customRange.classList.add('show');
          return;
        } else {
          customRange.classList.remove('show');
        }
      }

      loadData();
    }

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.custom-dropdown')) {
        closeAllDropdowns();
      }
    });

    /* ================================================
       SIDE SWITCHING
       ================================================ */
    function switchSide(side) {
      state.currentSide = side;
      document.querySelectorAll('.side-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.side === side);
      });
      if (currentDashboard === 'kpi') {
        kpiDataLoaded = false;
        loadKpiData();
      } else if (currentDashboard === 'ccs') {
        loadCcsData();
      } else {
        loadData();
      }
    }

    /* ================================================
       CUSTOM DATE RANGE
       ================================================ */
    function applyCustomDates() {
      const startInput = document.getElementById('customStartDate');
      const endInput = document.getElementById('customEndDate');

      if (!startInput.value || !endInput.value) {
        showError('Please select both start and end dates.');
        return;
      }

      const start = new Date(startInput.value);
      const end = new Date(endInput.value);
      const diffDays = Math.ceil((end - start) / 86400000) + 1;

      if (diffDays > 31) {
        showError('Custom date range cannot exceed 31 days.');
        return;
      }
      if (start > end) {
        showError('Start date must be before end date.');
        return;
      }

      state.customStart = startInput.value;
      state.customEnd = endInput.value;
      loadData();
    }

    /* ================================================
       MOVING AVERAGE TOGGLE
       ================================================ */
    function toggleNonProductiveDays() {
      state.showDashForNonProductive = !state.showDashForNonProductive;
      const btn = document.getElementById('maToggleBtn');
      const label = document.getElementById('maToggleLabel');

      if (state.showDashForNonProductive) {
        // When true: showing dashes for non-productive days
        btn.classList.add('active');
        label.textContent = 'Show Repeated Values';
      } else {
        // When false: showing repeated values for non-productive days
        btn.classList.remove('active');
        label.textContent = 'Show Non-Productive Days';
      }

      renderTable();
    }

    /* ================================================
       SETTINGS / PASSWORD MODALS
       ================================================ */
    document.getElementById('settingsBtn').addEventListener('click', () => {
      document.getElementById('password-modal').classList.add('show');
      const input = document.getElementById('passcodeInput');
      input.value = '';
      input.classList.remove('error');
      setTimeout(() => input.focus(), 100);
    });

    function closePasswordModal() {
      document.getElementById('password-modal').classList.remove('show');
    }

    function unlockSettings() {
      const input = document.getElementById('passcodeInput');
      if (input.value === CONFIG.settingsPassword) {
        closePasswordModal();
        openSettingsModal();
      } else {
        input.classList.add('error');
        setTimeout(() => input.classList.remove('error'), 500);
      }
    }

    function openSettingsModal() {
      document.getElementById('excellentMin').value = state.thresholds.excellent.min;
      document.getElementById('excellentMax').value = state.thresholds.excellent.max;
      document.getElementById('goodMin').value = state.thresholds.good.min;
      document.getElementById('goodMax').value = state.thresholds.good.max;
      document.getElementById('badMin').value = state.thresholds.bad.min;
      document.getElementById('badMax').value = state.thresholds.bad.max;
      updateRangePreview();
      document.getElementById('settings-modal').classList.add('show');
    }

    function closeSettingsModal() {
      document.getElementById('settings-modal').classList.remove('show');
    }

    function resetDefaults() {
      document.getElementById('excellentMin').value = 90;
      document.getElementById('excellentMax').value = 100;
      document.getElementById('goodMin').value = 50;
      document.getElementById('goodMax').value = 89;
      document.getElementById('badMin').value = 0;
      document.getElementById('badMax').value = 49;
      updateRangePreview();
    }

    function saveSettings() {
      state.thresholds.excellent.min = parseInt(document.getElementById('excellentMin').value) || 90;
      state.thresholds.excellent.max = parseInt(document.getElementById('excellentMax').value) || 100;
      state.thresholds.good.min = parseInt(document.getElementById('goodMin').value) || 50;
      state.thresholds.good.max = parseInt(document.getElementById('goodMax').value) || 89;
      state.thresholds.bad.min = parseInt(document.getElementById('badMin').value) || 0;
      state.thresholds.bad.max = parseInt(document.getElementById('badMax').value) || 49;

      localStorage.setItem('hzl_thresholds', JSON.stringify(state.thresholds));
      closeSettingsModal();
      renderTable();
    }

    function updateRangePreview() {
      const badMax = parseInt(document.getElementById('badMax').value) || 49;
      const goodMax = parseInt(document.getElementById('goodMax').value) || 89;
      const excellentMin = parseInt(document.getElementById('excellentMin').value) || 90;

      document.getElementById('rangeBad').style.flex = badMax + 1;
      document.getElementById('rangeBad').textContent = '< ' + (badMax + 1);
      document.getElementById('rangeGood').style.flex = goodMax - badMax;
      document.getElementById('rangeGood').textContent = (badMax + 1) + ' - ' + goodMax;
      document.getElementById('rangeExcellent').style.flex = 100 - goodMax;
      document.getElementById('rangeExcellent').textContent = excellentMin + ' <';
    }

    document.querySelectorAll('#settings-modal .setting-input').forEach(input => {
      input.addEventListener('input', updateRangePreview);
    });

    /* ================================================
       REJECTION SETTINGS
       ================================================ */
    function openRejSettingsModal() {
      document.getElementById('rejExcellentMax').value = state.rejThresholds.excellent;
      document.getElementById('rejGoodMax').value = state.rejThresholds.good;
      updateRejRangePreview();
      document.getElementById('rej-settings-modal').classList.add('show');
    }

    function closeRejSettingsModal() {
      document.getElementById('rej-settings-modal').classList.remove('show');
    }

    function resetRejDefaults() {
      document.getElementById('rejExcellentMax').value = 0;
      document.getElementById('rejGoodMax').value = 2;
      updateRejRangePreview();
    }

    function saveRejSettings() {
      state.rejThresholds.excellent = parseInt(document.getElementById('rejExcellentMax').value) || 0;
      state.rejThresholds.good = parseInt(document.getElementById('rejGoodMax').value) || 2;
      localStorage.setItem('hzl_rejThresholds', JSON.stringify(state.rejThresholds));
      closeRejSettingsModal();
      renderTable();
    }

    function updateRejRangePreview() {
      const excMax = parseInt(document.getElementById('rejExcellentMax').value) || 0;
      const goodMax = parseInt(document.getElementById('rejGoodMax').value) || 2;
      document.getElementById('rejBadLabel').textContent = goodMax;
      document.getElementById('rejRangeExcellent').style.flex = excMax + 1;
      document.getElementById('rejRangeExcellent').textContent = excMax === 0 ? '0' : '0 - ' + excMax;
      document.getElementById('rejRangeGood').style.flex = Math.max(goodMax - excMax, 1);
      document.getElementById('rejRangeGood').textContent = (excMax + 1) + ' - ' + goodMax;
      document.getElementById('rejRangeBad').style.flex = Math.max(3, goodMax + 1);
      document.getElementById('rejRangeBad').textContent = (goodMax + 1) + '+';
    }

    document.getElementById('rejExcellentMax').addEventListener('input', updateRejRangePreview);
    document.getElementById('rejGoodMax').addEventListener('input', updateRejRangePreview);

    /* ================================================
       CELL CHART
       ================================================ */
    let cellChartInstance = null;
    let currentChartCell = null;

    function openCellChart(cellNum) {
      isAvgChart = false;
      isKpiSingleSensor = false;
      currentChartCell = cellNum;
      const isCombined = state.efficiencyType === 'combined';
      let titlePrefix;
      if (activeDashConfig.rejectionMode) {
        titlePrefix = isCombined ? 'Combined Rejection Count' : 'Rejection Count';
      } else {
        titlePrefix = isCombined ? 'Combined Cell Efficiency' : 'Cell Efficiency';
      }
      document.getElementById('chart-title').innerHTML = `${titlePrefix} - <span>Cell No ${cellNum}</span>`;
      document.getElementById('chart-modal').classList.add('show');
      setTimeout(renderChart, 50);
    }

    let isKpiSingleSensor = false;
    let kpiSensorType = '';

    function openKpiCellChart(cellNum, sensor) {
      isAvgChart = false;
      isDistChart = false;
      isKpiSingleSensor = true;
      kpiSensorType = sensor;
      currentChartCell = cellNum;
      document.getElementById('chart-title').innerHTML = `Cell Efficiency - <span>Cell No ${cellNum} - ${sensor}</span>`;
      document.getElementById('chart-modal').classList.add('show');
      setTimeout(renderChart, 50);
    }

    function openKpiRejectionChart(cellNum, sensor) {
      // Temporarily switch to rejection mode to display rejection data
      const originalConfig = activeDashConfig;
      activeDashConfig = DASH_CONFIGS.rejection;

      isAvgChart = false;
      isDistChart = false;
      isKpiSingleSensor = true;
      kpiSensorType = sensor;
      currentChartCell = cellNum;
      document.getElementById('chart-title').innerHTML = `Rejected Cathodes - <span>Cell No ${cellNum} - ${sensor}</span>`;
      document.getElementById('chart-modal').classList.add('show');
      setTimeout(() => {
        renderChart();
        // Store original config to restore on close
        window.kpiOriginalConfig = originalConfig;
      }, 50);
    }

    let isAvgChart = false;

    function openAvgChart() {
      isAvgChart = true;
      currentChartCell = null;
      document.getElementById('chart-title').innerHTML = activeDashConfig.avgLabel;
      document.getElementById('chart-modal').classList.add('show');
      setTimeout(renderChart, 50);
    }

    let isDistChart = false;
    let distChartLabel = '';
    let distChartType = -1;

    function openDistChart(label, typeIdx) {
      isDistChart = true;
      isAvgChart = false;
      distChartLabel = label;
      distChartType = typeIdx;
      currentChartCell = null;
      const textColor = typeIdx === 0 ? '#16A34A' : typeIdx === 1 ? '#EA580C' : '#DC2626';
      document.getElementById('chart-title').innerHTML = `<span style="color:${textColor}">${label}</span> Cycle Count`;
      document.getElementById('chart-modal').classList.add('show');
      setTimeout(renderChart, 50);
    }

    function closeChartModal() {
      document.getElementById('chart-modal').classList.remove('show');
      closeExportMenu();
      isAvgChart = false;
      isDistChart = false;
      isKpiSingleSensor = false;
      kpiSensorType = '';
      distChartLabel = '';
      distChartType = -1;
      // Restore original config if it was changed for rejection chart
      if (window.kpiOriginalConfig) {
        activeDashConfig = window.kpiOriginalConfig;
        window.kpiOriginalConfig = null;
      }
      if (cellChartInstance) { cellChartInstance.destroy(); cellChartInstance = null; }
    }

    function toggleExportMenu() {
      document.getElementById('exportMenu').classList.toggle('show');
    }
    function closeExportMenu() {
      document.getElementById('exportMenu').classList.remove('show');
    }
    document.addEventListener('click', e => {
      if (!e.target.closest('.export-dropdown')) closeExportMenu();
    });

    function getSegmentColor(ctx, c1Data, c2Data, dateKeys, datasetIndex) {
      const idx = ctx.p1DataIndex;
      const dk = dateKeys[idx];
      const data = datasetIndex === 0 ? c1Data : c2Data;
      const val = data[dk];
      if (val === undefined || val === null) return '#CBD5E1';
      if (isExcellentValue(val)) return '#16A34A';
      if (isGoodValue(val)) return '#EA580C';
      return '#DC2626';
    }

    function getPointColor(val) {
      if (val === undefined || val === null) return '#CBD5E1';
      if (isExcellentValue(val)) return '#16A34A';
      if (isGoodValue(val)) return '#EA580C';
      return '#DC2626';
    }

    function showResetZoom() {
      document.getElementById('resetZoomBtn').style.display = 'flex';
    }
    function hideResetZoom() {
      document.getElementById('resetZoomBtn').style.display = 'none';
    }
    function resetChartZoom() {
      if (cellChartInstance) { cellChartInstance.resetZoom(); hideResetZoom(); }
    }

    function renderChart() {
      if (cellChartInstance) { cellChartInstance.destroy(); cellChartInstance = null; }
      hideResetZoom();
      const isCombined = state.efficiencyType === 'combined';
      const { start, end } = getDateRange();
      const dates = getDatesArray(start, end);
      const dateKeys = dates.map(d => formatDateKey(d));
      const labels = dates.map(d => formatDateHeader(d));

      // Distribution chart mode
      if (isDistChart) {
        const cellRange = getCellRange();
        const cellNums = [];
        for (let i = cellRange.start; i <= cellRange.end; i++) cellNums.push(i);
        const lineColor = distChartType === 0 ? '#16A34A' : distChartType === 1 ? '#EA580C' : '#DC2626';
        const bgColor = distChartType === 0 ? '#DCFCE7' : distChartType === 1 ? '#FFF7ED' : '#FEF2F2';
        const distMatchFn = distChartType === 0 ? isExcellentValue : distChartType === 1 ? isGoodValue : isBadValue;

        const countValues = dateKeys.map(dk => {
          let count = 0;
          cellNums.forEach(cn => {
            const ci = state.cellData[cn] || {};
            const c1 = (ci['C1'] || {})[dk], c2 = (ci['C2'] || {})[dk];
            const vals = [c1, c2].filter(v => v !== undefined && v !== null);
            if (vals.length > 0) {
              const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
              if (distMatchFn(avg)) count++;
            }
          });
          return count;
        });

        const maxCount = Math.max(...countValues, 1);
        const chartCtx = document.getElementById('cellChart').getContext('2d');
        cellChartInstance = new Chart(chartCtx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label: `${distChartLabel} Cycles`,
              data: countValues,
              borderColor: lineColor,
              backgroundColor: bgColor,
              pointBackgroundColor: lineColor,
              pointBorderColor: lineColor,
              pointStyle: 'rectRounded',
              pointRadius: 5,
              pointHoverRadius: 8,
              borderWidth: 2.5,
              tension: 0.3,
              fill: true,
              spanGaps: true,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
              legend: {
                display: true, position: 'bottom', align: 'center',
                labels: {
                  usePointStyle: true, padding: 20,
                  font: { family: 'Inter', size: 12, weight: '600' },
                  color: lineColor,
                }
              },
              tooltip: {
                backgroundColor: '#1A202C',
                titleFont: { family: 'Inter', size: 13, weight: '600' },
                bodyFont: { family: 'Inter', size: 12 },
                padding: 12, cornerRadius: 8,
                callbacks: { label: ctx => ` ${ctx.dataset.label}: ${ctx.parsed.y}` }
              },
              zoom: {
                zoom: {
                  drag: { enabled: true, backgroundColor: 'rgba(46,125,111,0.1)', borderColor: 'rgba(46,125,111,0.4)', borderWidth: 1 },
                  mode: 'x',
                  onZoomComplete: () => { showResetZoom(); }
                }
              }
            },
            scales: {
              x: { grid: { display: false }, ticks: { font: { family: 'Inter', size: 11, weight: '500' }, color: '#64748B' } },
              y: {
                min: 0, max: maxCount + Math.max(Math.ceil(maxCount * 0.2), 2),
                title: { display: true, text: 'Count', font: { family: 'Inter', size: 12, weight: '600' }, color: '#64748B' },
                grid: { color: '#F1F5F9' },
                ticks: { stepSize: 1, font: { family: 'Inter', size: 11, weight: '500' }, color: '#64748B' }
              }
            }
          },
          plugins: [{ id: 'dblClickReset', beforeEvent(chart, args) { if (args.event.type === 'dblclick') { chart.resetZoom(); hideResetZoom(); } } }]
        });
        return;
      }

      let c1Data, c2Data;

      if (isAvgChart) {
        // Avg chart always shows a single line (the daily combined average)
      } else {
        // For KPI dashboard in rejection mode, use rejectionData
        // For main dashboard (rejection or efficiency), use cellData (it contains the current mode's data)
        const dataSource = (isKpiSingleSensor && activeDashConfig.rejectionMode) ? state.rejectionData : state.cellData;
        const cellInfo = dataSource[currentChartCell] || {};
        c1Data = cellInfo['C1'] || {};
        c2Data = cellInfo['C2'] || {};
      }

      let datasets;
      let singleLineMode = isCombined || isAvgChart || isKpiSingleSensor;

      if (isKpiSingleSensor) {
        const sData = kpiSensorType === 'C1' ? c1Data : c2Data;
        const vals = dateKeys.map(dk => sData[dk] !== undefined ? Math.round(sData[dk] * 100) / 100 : null);
        const pointColors = vals.map(v => getPointColor(v));
        const pointIcon = kpiSensorType === 'C1' ? 'triangle' : 'circle';
        const dataLabel = activeDashConfig.rejectionMode ? `${kpiSensorType} Rejected Cathodes` : `${kpiSensorType} Efficiency`;
        datasets = [{
          label: dataLabel,
          data: vals,
          segment: { borderColor: ctx => { const idx = ctx.p1DataIndex; return getPointColor(vals[idx]); }},
          pointBackgroundColor: pointColors,
          pointBorderColor: pointColors,
          pointStyle: pointIcon,
          pointRadius: 5,
          pointHoverRadius: 8,
          borderWidth: 2.5,
          tension: 0.3,
          fill: false,
          spanGaps: true,
        }];
      } else if (singleLineMode) {
        const combinedDataMap = {};
        if (isAvgChart) {
          const cellRange = getCellRange();
          const cellNums = [];
          for (let i = cellRange.start; i <= cellRange.end; i++) cellNums.push(i);
          // Use state.cellData - it contains either efficiency or rejection data based on current dashboard
          dateKeys.forEach(dk => {
            const allValsDay = [];
            cellNums.forEach(cn => {
              const ci = state.cellData[cn] || {};
              const v1 = (ci['C1'] || {})[dk], v2 = (ci['C2'] || {})[dk];
              if (v1 !== undefined && v1 !== null) allValsDay.push(v1);
              if (v2 !== undefined && v2 !== null) allValsDay.push(v2);
            });
            if (activeDashConfig.rejectionMode) {
              // For rejection mode: calculate total (sum)
              combinedDataMap[dk] = allValsDay.length > 0 ? Math.round(allValsDay.reduce((a, b) => a + b, 0) * 100) / 100 : null;
            } else {
              // For efficiency mode: calculate average
              combinedDataMap[dk] = allValsDay.length > 0 ? Math.round((allValsDay.reduce((a, b) => a + b, 0) / allValsDay.length) * 100) / 100 : null;
            }
          });
        } else {
          dateKeys.forEach(dk => {
            const c1 = c1Data[dk], c2 = c2Data[dk];
            const vals = [c1, c2].filter(v => v !== undefined && v !== null);
            combinedDataMap[dk] = vals.length > 0 ? Math.round((vals.reduce((a, b) => a + b, 0) / vals.length) * 100) / 100 : null;
          });
        }
        const combValues = dateKeys.map(dk => combinedDataMap[dk]);
        const combPointColors = combValues.map(v => getPointColor(v));
        const chartLabel = isAvgChart ? activeDashConfig.avgLabel : (activeDashConfig.rejectionMode ? 'Combined Rejection Count' : 'Combined Efficiency');

        datasets = [{
          label: chartLabel,
          data: combValues,
          segment: { borderColor: ctx => {
            const idx = ctx.p1DataIndex;
            return getPointColor(combValues[idx]);
          }},
          pointBackgroundColor: combPointColors,
          pointBorderColor: combPointColors,
          pointStyle: 'rectRounded',
          pointRadius: 5,
          pointHoverRadius: 8,
          borderWidth: 2.5,
          tension: 0.3,
          fill: false,
          spanGaps: true,
        }];
      } else {
        const c1Values = dateKeys.map(dk => c1Data[dk] !== undefined ? Math.round(c1Data[dk] * 100) / 100 : null);
        const c2Values = dateKeys.map(dk => c2Data[dk] !== undefined ? Math.round(c2Data[dk] * 100) / 100 : null);
        const c1PointColors = c1Values.map(v => getPointColor(v));
        const c2PointColors = c2Values.map(v => getPointColor(v));

        datasets = [
          {
            label: activeDashConfig.c1Legend,
            data: c1Values,
            segment: { borderColor: ctx => getSegmentColor(ctx, c1Data, c2Data, dateKeys, 0) },
            pointBackgroundColor: c1PointColors,
            pointBorderColor: c1PointColors,
            pointStyle: 'triangle',
            pointRadius: 6,
            pointHoverRadius: 9,
            borderWidth: 2.5,
            tension: 0.3,
            fill: false,
            spanGaps: true,
          },
          {
            label: activeDashConfig.c2Legend,
            data: c2Values,
            segment: { borderColor: ctx => getSegmentColor(ctx, c1Data, c2Data, dateKeys, 1) },
            pointBackgroundColor: c2PointColors,
            pointBorderColor: c2PointColors,
            pointStyle: 'circle',
            pointRadius: 5,
            pointHoverRadius: 8,
            borderWidth: 2.5,
            tension: 0.3,
            fill: false,
            spanGaps: true,
          }
        ];
      }

      const allVals = datasets.flatMap(ds => ds.data).filter(v => v !== null);
      const dataMin = allVals.length ? Math.min(...allVals) : 0;
      const dataMax = allVals.length ? Math.max(...allVals) : 100;
      const range = dataMax - dataMin;

      let yMin, yMax;
      if (activeDashConfig.rejectionMode) {
        // For rejection mode: use dynamic scaling to center the trend
        const padding = Math.max(range * 0.4, Math.max(dataMax * 0.3, 5));
        yMin = Math.max(0, Math.floor(dataMin - padding));
        yMax = Math.ceil(dataMax + padding);
      } else {
        // For efficiency mode: keep percentage scaling (0-100)
        const padding = Math.max(range * 0.3, 3);
        yMin = Math.max(0, Math.floor(dataMin - padding));
        yMax = Math.min(100, Math.ceil(dataMax + padding));
      }

      const legendColors = ['#2563EB', '#E11D48'];
      const legendConfig = singleLineMode ? {
        display: true,
        position: 'bottom',
        align: 'center',
        labels: {
          usePointStyle: true,
          pointStyle: 'rectRounded',
          padding: 20,
          font: { family: 'Inter', size: 12, weight: '600' },
          color: '#334155',
        }
      } : {
        display: true,
        position: 'bottom',
        align: 'center',
        labels: {
          usePointStyle: true,
          pointStyle: (ctx) => ctx.datasetIndex === 0 ? 'triangle' : 'circle',
          padding: 20,
          font: { family: 'Inter', size: 12, weight: '600' },
          generateLabels: (chart) => {
            return chart.data.datasets.map((ds, i) => ({
              text: ds.label,
              datasetIndex: i,
              hidden: !chart.isDatasetVisible(i),
              fillStyle: legendColors[i],
              strokeStyle: legendColors[i],
              pointStyle: i === 0 ? 'triangle' : 'circle',
              fontColor: legendColors[i],
            }));
          },
        },
        onClick: (e, legendItem, legend) => {
          const idx = legendItem.datasetIndex;
          const meta = legend.chart.getDatasetMeta(idx);
          meta.hidden = !meta.hidden;
          legend.chart.update();
        }
      };

      const tooltipCallbacks = singleLineMode ? {
        label: ctx => {
          const value = ctx.parsed.y !== null ? ctx.parsed.y : 'N/A';
          const suffix = activeDashConfig.rejectionMode ? '' : '%';
          return ` ${ctx.dataset.label}: ${value !== 'N/A' ? value + suffix : value}`;
        },
      } : {
        label: ctx => {
          const value = ctx.parsed.y !== null ? ctx.parsed.y : 'N/A';
          const suffix = activeDashConfig.rejectionMode ? '' : '%';
          return ` ${ctx.dataset.label}: ${value !== 'N/A' ? value + suffix : value}`;
        },
        labelPointStyle: ctx => ({ pointStyle: ctx.datasetIndex === 0 ? 'triangle' : 'circle' }),
        labelColor: ctx => ({
          borderColor: legendColors[ctx.datasetIndex],
          backgroundColor: legendColors[ctx.datasetIndex],
        })
      };

      const chartCtx = document.getElementById('cellChart').getContext('2d');
      cellChartInstance = new Chart(chartCtx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: legendConfig,
            tooltip: {
              backgroundColor: '#1A202C',
              titleFont: { family: 'Inter', size: 13, weight: '600' },
              bodyFont: { family: 'Inter', size: 12 },
              padding: 12,
              cornerRadius: 8,
              usePointStyle: true,
              callbacks: tooltipCallbacks
            },
            zoom: {
              zoom: {
                drag: { enabled: true, backgroundColor: 'rgba(46,125,111,0.1)', borderColor: 'rgba(46,125,111,0.4)', borderWidth: 1 },
                mode: 'x',
                onZoomComplete: () => { showResetZoom(); }
              }
            }
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: { font: { family: 'Inter', size: 11, weight: '500' }, color: '#64748B' }
            },
            y: {
              min: yMin,
              max: yMax,
              title: {
                display: true,
                text: activeDashConfig.chartYLabel,
                font: { family: 'Inter', size: 12, weight: '600' },
                color: '#64748B',
              },
              grid: { color: '#F1F5F9' },
              ticks: {
                font: { family: 'Inter', size: 11, weight: '500' },
                color: '#64748B',
              }
            }
          },
        },
        plugins: [{
          id: 'dblClickReset',
          beforeEvent(chart, args) {
            if (args.event.type === 'dblclick') { chart.resetZoom(); hideResetZoom(); }
          }
        }]
      });
    }

    function downloadChartImage() {
      closeExportMenu();
      if (!cellChartInstance) return;
      const link = document.createElement('a');
      const fname = isDistChart ? `${distChartLabel}_Cycle_Count` : isAvgChart ? 'Avg_Cell_Efficiency' : `Cell_No_${currentChartCell}_Efficiency`;
      link.download = `${fname}.png`;
      link.href = cellChartInstance.toBase64Image('image/png', 1);
      link.click();
    }

    function downloadChartExcel() {
      closeExportMenu();
      if (!currentChartCell && !isAvgChart && !isDistChart) return;
      const isCombined = state.efficiencyType === 'combined';
      const { start, end } = getDateRange();
      const dates = getDatesArray(start, end);
      const dateKeys = dates.map(d => formatDateKey(d));
      const labels = dates.map(d => formatDateHeader(d));

      let csv;
      const fname = isDistChart ? `${distChartLabel}_Cycle_Count` : isAvgChart ? 'Avg_Cell_Efficiency' : `Cell_No_${currentChartCell}_Efficiency`;

      if (isDistChart) {
        const cellRange = getCellRange();
        const cellNums = [];
        for (let i = cellRange.start; i <= cellRange.end; i++) cellNums.push(i);
        csv = `Date,${distChartLabel} Count\n`;
        dateKeys.forEach((dk, i) => {
          let count = 0;
          const distExMatchFn = distChartType === 0 ? isExcellentValue : distChartType === 1 ? isGoodValue : isBadValue;
          cellNums.forEach(cn => {
            const ci = state.cellData[cn] || {};
            const c1 = (ci['C1'] || {})[dk], c2 = (ci['C2'] || {})[dk];
            const vals = [c1, c2].filter(v => v !== undefined && v !== null);
            if (vals.length > 0) {
              const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
              if (distExMatchFn(avg)) count++;
            }
          });
          csv += `${labels[i]},${count}\n`;
        });
      } else if (isAvgChart) {
        const cellRange = getCellRange();
        const cellNums = [];
        for (let i = cellRange.start; i <= cellRange.end; i++) cellNums.push(i);
        csv = `Date,${activeDashConfig.avgLabel}\n`;
        dateKeys.forEach((dk, i) => {
          const allVals = [];
          cellNums.forEach(cn => {
            const ci = state.cellData[cn] || {};
            const v1 = (ci['C1'] || {})[dk], v2 = (ci['C2'] || {})[dk];
            if (v1 !== undefined && v1 !== null) allVals.push(v1);
            if (v2 !== undefined && v2 !== null) allVals.push(v2);
          });
          const avg = allVals.length > 0 ? Math.round((allVals.reduce((a, b) => a + b, 0) / allVals.length) * 100) / 100 : '';
          csv += `${labels[i]},${avg}\n`;
        });
      } else {
        const cellInfo = state.cellData[currentChartCell] || {};
        const c1Data = cellInfo['C1'] || {};
        const c2Data = cellInfo['C2'] || {};
        if (isCombined) {
          csv = 'Date,Combined Efficiency (%)\n';
          dateKeys.forEach((dk, i) => {
            const c1 = c1Data[dk], c2 = c2Data[dk];
            const vals = [c1, c2].filter(v => v !== undefined && v !== null);
            const avg = vals.length > 0 ? Math.round((vals.reduce((a, b) => a + b, 0) / vals.length) * 100) / 100 : '';
            csv += `${labels[i]},${avg}\n`;
          });
        } else {
          csv = `Date,${activeDashConfig.c1Legend},${activeDashConfig.c2Legend}\n`;
          dateKeys.forEach((dk, i) => {
            const c1 = c1Data[dk] !== undefined ? Math.round(c1Data[dk] * 100) / 100 : '';
            const c2 = c2Data[dk] !== undefined ? Math.round(c2Data[dk] * 100) / 100 : '';
            csv += `${labels[i]},${c1},${c2}\n`;
          });
        }
      }

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.download = `${fname}.csv`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    }

    /* ================================================
       TABLE EXPORT
       ================================================ */
    function toggleTableExportMenu() {
      document.getElementById('tableExportMenu').classList.toggle('show');
    }
    function closeTableExportMenu() {
      document.getElementById('tableExportMenu').classList.remove('show');
    }
    document.addEventListener('click', e => {
      if (!e.target.closest('#tableExportDropdown')) closeTableExportMenu();
    });

    function getColorForClass(cls) {
      if (cls.includes('cell-excellent')) return { bg: '#DCFCE7', color: '#16A34A' };
      if (cls.includes('cell-good')) return { bg: '#FFF7ED', color: '#EA580C' };
      if (cls.includes('cell-bad')) return { bg: '#FEF2F2', color: '#DC2626' };
      if (cls.includes('cell-nodata')) return { bg: '#FAFAFA', color: '#CBD5E1' };
      return { bg: '#FFFFFF', color: '#1A202C' };
    }

    function buildExportTable() {
      const isCombined = state.efficiencyType === 'combined';
      const isRejExport = activeDashConfig.rejectionMode;
      const isMovAvgExport = state.cycleType === 'moving_avg';
      const showExcColExport = !isCombined && !isRejExport && !isMovAvgExport;
      const showAvgColExport = !isMovAvgExport;
      const showSummaryExport = !isMovAvgExport;
      const { start, end } = getDateRange();
      const dates = getDatesArray(start, end);
      const dateKeys = dates.map(d => formatDateKey(d));
      const labels = dates.map(d => formatDateHeader(d));
      const cellRange = getCellRange();
      const cellNums = [];
      for (let i = cellRange.start; i <= cellRange.end; i++) cellNums.push(i);

      const cellStyle = 'border:1px solid #E2E8F0;padding:6px 10px;text-align:center;font-size:12px;font-family:Inter,Arial,sans-serif;';
      const headerStyle = cellStyle + 'background:#FAFBFC;color:#4A5568;font-weight:600;font-size:13px;';
      const noNewCycleExtra = 'font-style:italic;text-decoration:underline;opacity:0.75;';

      let html = '<table style="border-collapse:collapse;">';

      // Calculate total columns
      let totalCols = 1 + labels.length; // Cell column + date columns
      if (!isCombined) totalCols++; // Selection column
      if (showAvgColExport) totalCols++; // Average column
      if (showExcColExport) totalCols++; // Excellent column

      // Main header: Cell Efficiency Monitoring
      html += `<tr><th colspan="${totalCols}" style="${cellStyle}background:#0F172A;color:#FFFFFF;font-weight:700;font-size:16px;padding:12px;">Cell Efficiency Monitoring</th></tr>`;

      // Sub-header with dashboard name and context
      let dashboardName = isRejExport ? 'Rejected Cathode Count' : 'Cell Efficiency Heatmap';
      let cycleInfo = isMovAvgExport ? 'Last 3 Cycle Moving Average' : 'Individual Cycle';
      let effInfo = isCombined ? 'Combined Efficiency' : 'C1/C2 Efficiency';
      let sideInfo = state.currentSide === 'east' ? 'East Side CSM 2' : 'West Side';

      let subtitle = '';
      if (isRejExport) {
        subtitle = `${dashboardName} | ${cycleInfo} | ${sideInfo}`;
      } else {
        subtitle = `${dashboardName} | ${cycleInfo} | ${effInfo} | ${sideInfo}`;
      }

      html += `<tr><th colspan="${totalCols}" style="${cellStyle}background:#1E3A5F;color:#FFFFFF;font-weight:600;font-size:14px;padding:10px;">${subtitle}</th></tr>`;

      // Duration line
      const duration = getFormattedDuration(isRejExport ? 'rejection' : 'heatmap');
      html += `<tr><th colspan="${totalCols}" style="${cellStyle}background:#F0F4F8;color:#4A5568;font-weight:500;font-size:12px;padding:8px;">${duration}</th></tr>`;

      // Empty row for spacing
      html += `<tr><td colspan="${totalCols}" style="height:10px;border:none;"></td></tr>`;

      // Column headers
      html += '<tr>';
      html += `<th style="${headerStyle}min-width:100px;">Cell</th>`;
      if (!isCombined) html += `<th style="${headerStyle}">Selection</th>`;
      labels.forEach(l => { html += `<th style="${headerStyle}">${l}</th>`; });
      if (showAvgColExport) html += `<th style="${headerStyle}min-width:100px;">${activeDashConfig.avgLabel}</th>`;
      if (showExcColExport) html += `<th style="${headerStyle}min-width:110px;">${activeDashConfig.excellentLabel}</th>`;
      html += '</tr>';

      const allDayC1 = {}, allDayC2 = {}, allDayComb = {};
      dateKeys.forEach(dk => { allDayC1[dk] = []; allDayC2[dk] = []; allDayComb[dk] = []; });
      let totalExc = 0, totalCyc = 0;

      // Placeholder for total row - will be filled later
      let totalRowInsertionPoint = html.length;

      if (isCombined) {
        cellNums.forEach(cn => {
          const ci = state.cellData[cn] || {};
          const c1Raw = ci['C1'] || {}, c2Raw = ci['C2'] || {};

          let maData = null;
          if (isMovAvgExport) {
            const combRaw = {};
            const allKeys = new Set([...Object.keys(c1Raw), ...Object.keys(c2Raw)]);
            allKeys.forEach(k => {
              const v1 = c1Raw[k], v2 = c2Raw[k];
              const vals = [v1, v2].filter(v => v !== undefined && v !== null);
              if (vals.length > 0) combRaw[k] = vals.reduce((a, b) => a + b, 0) / vals.length;
            });
            maData = computeMovingAvg(combRaw, dates);
          }

          html += '<tr>';
          html += `<td style="${cellStyle}font-weight:700;color:#1B5E50;">Cell No ${cn}</td>`;
          dateKeys.forEach(dk => {
            if (isMovAvgExport) {
              const ma = maData ? maData[dk] : null;
              if (ma) {
                allDayComb[dk].push(ma.value);
                const c = getColorForClass(getCellClass(ma.value));
                const extra = ma.hasNewCycle ? '' : noNewCycleExtra;
                html += `<td style="${cellStyle}background:${c.bg};color:${c.color};font-weight:600;${extra}">${Math.round(ma.value)}</td>`;
              } else { html += `<td style="${cellStyle}background:#FAFAFA;color:#CBD5E1;">--</td>`; }
            } else {
              const v1 = c1Raw[dk], v2 = c2Raw[dk];
              const pair = [v1, v2].filter(v => v !== undefined && v !== null);
              if (pair.length > 0) {
                const avg = pair.reduce((a, b) => a + b, 0) / pair.length;
                allDayComb[dk].push(avg);
                const c = getColorForClass(getCellClass(avg));
                html += `<td style="${cellStyle}background:${c.bg};color:${c.color};font-weight:600;">${Math.round(avg)}</td>`;
              } else { html += `<td style="${cellStyle}background:#FAFAFA;color:#CBD5E1;">--</td>`; }
            }
          });
          if (showAvgColExport) {
            const vals = dateKeys.map(dk => allDayComb[dk]).flat();
            const cellVals = [];
            dateKeys.forEach(dk => { if (allDayComb[dk].length > 0) cellVals.push(allDayComb[dk][allDayComb[dk].length - 1]); });
            const avg = cellVals.length ? cellVals.reduce((a, b) => a + b, 0) / cellVals.length : null;
            const ac = getColorForClass(getCellClass(avg));
            html += `<td style="${cellStyle}background:${ac.bg};color:${ac.color};font-weight:700;">${avg !== null ? Math.round(avg) + (activeDashConfig.showPercent ? '%' : '') : '--'}</td>`;
          }
          html += '</tr>';
        });
      } else {
        cellNums.forEach(cn => {
          const ci = state.cellData[cn] || {};
          const c1Raw = ci['C1'] || {}, c2Raw = ci['C2'] || {};

          let maC1 = null, maC2 = null;
          if (isMovAvgExport) {
            maC1 = computeMovingAvg(c1Raw, dates);
            maC2 = computeMovingAvg(c2Raw, dates);
          }

          // C1
          let c1Exc = 0, c1Tot = 0;
          html += '<tr>';
          html += `<td rowspan="2" style="${cellStyle}font-weight:700;color:#1B5E50;vertical-align:middle;">Cell No ${cn}</td>`;
          html += `<td style="${cellStyle}font-weight:600;color:#64748B;">C1</td>`;
          dateKeys.forEach(dk => {
            if (isMovAvgExport) {
              const ma = maC1 ? maC1[dk] : null;
              if (ma) {
                allDayC1[dk].push(ma.value);
                const c = getColorForClass(getCellClass(ma.value));
                const extra = ma.hasNewCycle ? '' : noNewCycleExtra;
                html += `<td style="${cellStyle}background:${c.bg};color:${c.color};font-weight:600;${extra}">${Math.round(ma.value)}</td>`;
              } else { html += `<td style="${cellStyle}background:#FAFAFA;color:#CBD5E1;">--</td>`; }
            } else {
              const val = c1Raw[dk];
              if (val !== undefined && val !== null) {
                c1Tot++;
                if (isExcellentValue(val)) c1Exc++;
                allDayC1[dk].push(val);
                const c = getColorForClass(getCellClass(val));
                html += `<td style="${cellStyle}background:${c.bg};color:${c.color};font-weight:600;">${Math.round(val)}</td>`;
              } else { html += `<td style="${cellStyle}background:#FAFAFA;color:#CBD5E1;">--</td>`; }
            }
          });
          if (showAvgColExport) {
            const c1Vals = dateKeys.map(dk => allDayC1[dk]).flat().filter(v => v !== undefined);
            const c1Avg = c1Vals.length ? c1Vals.reduce((a, b) => a + b, 0) / c1Vals.length : null;
            const c1c = getColorForClass(getCellClass(c1Avg));
            html += `<td style="${cellStyle}background:${c1c.bg};color:${c1c.color};font-weight:700;">${c1Avg !== null ? Math.round(c1Avg) + (activeDashConfig.showPercent ? '%' : '') : '--'}</td>`;
          }
          if (showExcColExport) {
            const excCls = getExcellentCycleClass(c1Exc, c1Tot);
            const excCol = getColorForClass(excCls);
            html += `<td style="${cellStyle}background:${excCol.bg};color:${excCol.color};font-weight:600;">${c1Tot > 0 ? c1Exc + ' out of ' + c1Tot : '--'}</td>`;
          }
          html += '</tr>';
          totalExc += c1Exc; totalCyc += c1Tot;

          // C2
          let c2Exc = 0, c2Tot = 0;
          html += '<tr>';
          html += `<td style="${cellStyle}font-weight:600;color:#64748B;">C2</td>`;
          dateKeys.forEach(dk => {
            if (isMovAvgExport) {
              const ma = maC2 ? maC2[dk] : null;
              if (ma) {
                allDayC2[dk].push(ma.value);
                const c = getColorForClass(getCellClass(ma.value));
                const extra = ma.hasNewCycle ? '' : noNewCycleExtra;
                html += `<td style="${cellStyle}background:${c.bg};color:${c.color};font-weight:600;${extra}">${Math.round(ma.value)}</td>`;
              } else { html += `<td style="${cellStyle}background:#FAFAFA;color:#CBD5E1;">--</td>`; }
            } else {
              const val = c2Raw[dk];
              if (val !== undefined && val !== null) {
                c2Tot++;
                if (isExcellentValue(val)) c2Exc++;
                allDayC2[dk].push(val);
                const c = getColorForClass(getCellClass(val));
                html += `<td style="${cellStyle}background:${c.bg};color:${c.color};font-weight:600;">${Math.round(val)}</td>`;
              } else { html += `<td style="${cellStyle}background:#FAFAFA;color:#CBD5E1;">--</td>`; }
            }
          });
          if (showAvgColExport) {
            const c2Vals = dateKeys.map(dk => allDayC2[dk]).flat().filter(v => v !== undefined);
            const c2Avg = c2Vals.length ? c2Vals.reduce((a, b) => a + b, 0) / c2Vals.length : null;
            const c2c = getColorForClass(getCellClass(c2Avg));
            html += `<td style="${cellStyle}background:${c2c.bg};color:${c2c.color};font-weight:700;">${c2Avg !== null ? Math.round(c2Avg) + (activeDashConfig.showPercent ? '%' : '') : '--'}</td>`;
          }
          if (showExcColExport) {
            const exc2Cls = getExcellentCycleClass(c2Exc, c2Tot);
            const exc2Col = getColorForClass(exc2Cls);
            html += `<td style="${cellStyle}background:${exc2Col.bg};color:${exc2Col.color};font-weight:600;">${c2Tot > 0 ? c2Exc + ' out of ' + c2Tot : '--'}</td>`;
          }
          html += '</tr>';
          totalExc += c2Exc; totalCyc += c2Tot;
        });
      }

      // Build total/avg row data for later insertion
      let totalRowHTML = '';
      if (showSummaryExport) {
        // Avg/Total Row
        const avgStyle = cellStyle + 'background:#F0F9FF;font-weight:700;font-size:13px;border-top:2px solid #2E7D6F;';
        const totalRowLabel = isRejExport ? 'Total Rejection' : activeDashConfig.avgLabel;
        totalRowHTML += '<tr>';
        totalRowHTML += `<td style="${avgStyle}color:#1A202C;">${totalRowLabel}</td>`;
        if (!isCombined) totalRowHTML += `<td style="${avgStyle}color:#64748B;">--</td>`;
        let allAvg = [];
        let allTotal = [];
        const pctSuffix = activeDashConfig.showPercent ? '%' : '';
        dateKeys.forEach(dk => {
          const vals = isCombined ? (allDayComb[dk] || []) : [...(allDayC1[dk] || []), ...(allDayC2[dk] || [])];
          if (vals.length > 0) {
            if (isRejExport) {
              // For rejection mode: calculate total (sum)
              const total = vals.reduce((a, b) => a + b, 0);
              allTotal.push(total);
              const c = getColorForClass(getCellClass(total));
              totalRowHTML += `<td style="${avgStyle}background:${c.bg};color:${c.color};">${Math.round(total)}</td>`;
            } else {
              // For efficiency mode: calculate average
              const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
              allAvg.push(avg);
              const c = getColorForClass(getCellClass(avg));
              totalRowHTML += `<td style="${avgStyle}background:${c.bg};color:${c.color};">${Math.round(avg)}${pctSuffix}</td>`;
            }
          } else { totalRowHTML += `<td style="${avgStyle}color:#CBD5E1;">--</td>`; }
        });

        if (isRejExport) {
          // For rejection mode: show total of all totals
          const grandTotal = allTotal.length ? allTotal.reduce((a, b) => a + b, 0) : null;
          const gtc = getColorForClass(getCellClass(grandTotal));
          totalRowHTML += `<td style="${avgStyle}background:${gtc.bg};color:${gtc.color};">${grandTotal !== null ? Math.round(grandTotal) : '--'}</td>`;
        } else {
          // For efficiency mode: show average
          const oa = allAvg.length ? allAvg.reduce((a, b) => a + b, 0) / allAvg.length : null;
          const oac = getColorForClass(getCellClass(oa));
          totalRowHTML += `<td style="${avgStyle}background:${oac.bg};color:${oac.color};">${oa !== null ? Math.round(oa) + pctSuffix : '--'}</td>`;
        }

        if (showExcColExport) {
          const ecc = getColorForClass(getExcellentCycleClass(totalExc, totalCyc));
          totalRowHTML += `<td style="${avgStyle}background:${ecc.bg};color:${ecc.color};">${totalCyc > 0 ? totalExc + ' out of ' + totalCyc : '--'}</td>`;
        }
        totalRowHTML += '</tr>';

        // CE Distribution
        const allDayAll = {};
        dateKeys.forEach(dk => {
          allDayAll[dk] = isCombined ? (allDayComb[dk] || []) : [...(allDayC1[dk] || []), ...(allDayC2[dk] || [])];
        });
        const expDistLabels = activeDashConfig.rejectionMode
          ? getRejDistLabels()
          : [{l:'Excellent',fn:v=>isExcellentValue(v)},{l:'Good',fn:v=>isGoodValue(v)},{l:'Bad',fn:v=>isBadValue(v)}];
        const distColorsArr = ['#16A34A', '#EA580C', '#DC2626'];
        expDistLabels.forEach((dl, li) => {
          html += '<tr>';
          if (li === 0) {
            html += `<td rowspan="3" style="${cellStyle}font-weight:800;font-size:12px;vertical-align:middle;">${activeDashConfig.distLabel}</td>`;
          }
          const tc = distColorsArr[li];
          html += `<td style="${cellStyle}color:${tc};font-weight:700;">${dl.l}</td>`;
          dateKeys.forEach(dk => {
            const dayVals = allDayAll[dk] || [];
            if (dayVals.length === 0) {
              html += `<td style="${cellStyle}color:#CBD5E1;">--</td>`;
            } else {
              let count = 0;
              dayVals.forEach(v => { if (dl.fn(v)) count++; });
              html += `<td style="${cellStyle}color:${tc};font-weight:600;">${count}</td>`;
            }
          });
          html += `<td style="${cellStyle}color:${tc};font-weight:700;">--</td>`;
          if (showExcColExport) html += `<td style="${cellStyle}">--</td>`;
          html += '</tr>';
        });
      }

      // Insert total row at the top (after header row) if available
      if (showSummaryExport && totalRowHTML) {
        html = html.substring(0, totalRowInsertionPoint) + totalRowHTML + html.substring(totalRowInsertionPoint);
      }

      html += '</table>';
      return html;
    }

    function exportTableCSV() {
      closeTableExportMenu();
      const htmlTable = buildExportTable();
      const sheetName = activeDashConfig.rejectionMode ? 'Rejected Cathode Count' : 'Cell Efficiency';
      const fullHtml = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
<head><meta charset="utf-8"><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>${sheetName}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head>
<body>${htmlTable}</body></html>`;
      const blob = new Blob([fullHtml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
      const link = document.createElement('a');
      const side = state.currentSide === 'east' ? 'East_Side' : 'West_Side';
      const filePrefix = activeDashConfig.rejectionMode ? 'Rejected_Cathode_Count' : 'Cell_Efficiency';
      const movAvgSuffix = state.cycleType === 'moving_avg' ? '_Moving_Avg' : '';
      link.download = `${filePrefix}${movAvgSuffix}_${side}_${new Date().toISOString().slice(0,10)}.xls`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function exportTableImage() {
      closeTableExportMenu();
      const htmlTable = buildExportTable();
      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.left = '-9999px';
      container.style.top = '0';
      container.innerHTML = htmlTable;
      document.body.appendChild(container);
      const tbl = container.querySelector('table');
      const tRows = tbl.querySelectorAll('tr');

      // Find the actual column count by looking for the first row without colspan
      // (first few rows are headers with full-width colspan)
      let colCount = 0;
      for (let i = 0; i < tRows.length; i++) {
        const cells = tRows[i].querySelectorAll('th, td');
        let totalCols = 0;
        cells.forEach(cell => {
          const colspan = parseInt(cell.getAttribute('colspan')) || 1;
          totalCols += colspan;
        });
        if (totalCols > colCount) {
          colCount = totalCols;
        }
      }

      const rowHeights = [];
      const colWidths = new Array(colCount).fill(65);

      const measureCanvas = document.createElement('canvas');
      const mCtx = measureCanvas.getContext('2d');
      mCtx.font = '600 13px Inter, Arial, sans-serif';

      tRows.forEach((row, ri) => {
        // Calculate row height based on position
        // Row 0: Main header (larger)
        // Row 1: Sub-header
        // Row 2: Duration
        // Row 3: Empty spacing
        // Row 4: Column headers
        // Row 5+: Data rows
        let rowHeight = 28; // Default data row height
        if (ri === 0) rowHeight = 40; // Main header
        else if (ri === 1) rowHeight = 32; // Sub-header
        else if (ri === 2) rowHeight = 28; // Duration
        else if (ri === 3) rowHeight = 10; // Spacing
        else if (ri === 4) rowHeight = 36; // Column headers

        rowHeights.push(rowHeight);

        const cells = row.querySelectorAll('th, td');
        let ci = 0;
        cells.forEach(cell => {
          const colspan = parseInt(cell.getAttribute('colspan')) || 1;
          const text = cell.innerText.trim();
          const w = mCtx.measureText(text).width + 24;
          const perCol = w / colspan;
          for (let c = 0; c < colspan; c++) {
            if (ci + c < colCount && perCol > colWidths[ci + c]) colWidths[ci + c] = perCol;
          }
          ci += colspan;
        });
      });

      document.body.removeChild(container);

      const totalWidth = colWidths.reduce((a, b) => a + b, 0);
      const totalHeight = rowHeights.reduce((a, b) => a + b, 0);

      const canvas = document.createElement('canvas');
      const scale = 2;
      canvas.width = totalWidth * scale;
      canvas.height = totalHeight * scale;
      canvas.style.width = totalWidth + 'px';
      canvas.style.height = totalHeight + 'px';
      const ctx = canvas.getContext('2d');
      ctx.scale(scale, scale);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, totalWidth, totalHeight);

      const rowspanTracker = new Array(colCount).fill(0);

      let y = 0;
      tRows.forEach((row, ri) => {
        const rh = rowHeights[ri];
        const cells = row.querySelectorAll('th, td');
        let ci = 0;
        let cellIdx = 0;

        while (ci < colCount) {
          if (rowspanTracker[ci] > 0) {
            rowspanTracker[ci]--;
            ci++;
            continue;
          }
          if (cellIdx >= cells.length) break;
          const cell = cells[cellIdx];
          const colspan = parseInt(cell.getAttribute('colspan')) || 1;
          const rowspan = parseInt(cell.getAttribute('rowspan')) || 1;
          const cellW = colWidths.slice(ci, ci + colspan).reduce((a, b) => a + b, 0);
          const cellH = rowHeights.slice(ri, ri + rowspan).reduce((a, b) => a + b, 0);
          const x = colWidths.slice(0, ci).reduce((a, b) => a + b, 0);

          const bgColor = cell.style.background || cell.style.backgroundColor || (ri <= 4 ? '#FAFBFC' : '#FFFFFF');
          ctx.fillStyle = bgColor;
          ctx.fillRect(x, y, cellW, cellH);

          const textColor = cell.style.color || (ri <= 4 ? '#4A5568' : '#1A202C');
          const fw = cell.style.fontWeight || '500';

          // Font size based on row type
          let fs = 12; // Default data row
          if (ri === 0) fs = 16; // Main header
          else if (ri === 1) fs = 14; // Sub-header
          else if (ri === 2) fs = 12; // Duration
          else if (ri === 4) fs = 13; // Column headers

          ctx.fillStyle = textColor;
          ctx.font = `${fw} ${fs}px Inter, Arial, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(cell.innerText.trim(), x + cellW / 2, y + cellH / 2);

          ctx.strokeStyle = '#E2E8F0';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x, y, cellW, cellH);

          for (let rs = 1; rs < rowspan; rs++) {
            rowspanTracker[ci] = rowspan - 1;
            for (let cs = 1; cs < colspan; cs++) {
              if (ci + cs < colCount) rowspanTracker[ci + cs] = rowspan - 1;
            }
          }
          if (rowspan > 1) {
            for (let cs = 0; cs < colspan; cs++) {
              if (ci + cs < colCount) rowspanTracker[ci + cs] = rowspan - 1;
            }
          }

          ci += colspan;
          cellIdx++;
        }
        y += rh;
      });

      canvas.toBlob(blob => {
        const link = document.createElement('a');
        const side = state.currentSide === 'east' ? 'East_Side' : 'West_Side';
        link.download = `Cell_Efficiency_${side}_${new Date().toISOString().slice(0,10)}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
      });
    }

    /* ================================================
       KPI DASHBOARD
       ================================================ */
    let kpiMode = 'best';
    let kpiDataType = 'efficiency';
    let kpiData = null;
    let kpiRejectionData = null;
    let kpiDataLoaded = false;
    let currentDashboard = 'heatmap';

    function switchDashboard(view) {
      currentDashboard = view;
      document.querySelectorAll('.sub-nav-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.sub-nav-tab[onclick="switchDashboard('${view}')"]`).classList.add('active');

      const heatmapArea = document.getElementById('content-area');
      const kpiArea = document.getElementById('kpi-area');
      const ccsArea = document.getElementById('ccs-area');

      const ddCycle = document.getElementById('dd-cycle');
      const ddEfficiency = document.getElementById('dd-efficiency');
      const rejSettingsBtn = document.getElementById('rejSettingsBtn');

      heatmapArea.style.display = 'none';
      kpiArea.style.display = 'none';
      ccsArea.style.display = 'none';

      if (view === 'kpi') {
        kpiArea.style.display = 'block';
        ddCycle.style.display = '';
        ddEfficiency.style.display = '';
        rejSettingsBtn.style.display = 'none';
        document.getElementById('maToggleBtn').style.display = 'none';
        kpiDataLoaded = false;
        loadKpiData();
      } else if (view === 'rejection') {
        activeDashConfig = DASH_CONFIGS.rejection;
        state.cycleType = 'individual';
        state.efficiencyType = 'c1c2';
        ddCycle.style.display = 'none';
        ddEfficiency.style.display = 'none';
        rejSettingsBtn.style.display = 'inline-flex';
        document.getElementById('maToggleBtn').style.display = 'none';
        heatmapArea.style.display = 'block';
        loadData();
      } else if (view === 'ccs') {
        ddCycle.style.display = 'none';
        ddEfficiency.style.display = 'none';
        rejSettingsBtn.style.display = 'none';
        document.getElementById('maToggleBtn').style.display = 'none';
        ccsArea.style.display = 'block';
        // Load cold spot configuration from IOsense SDK
        loadColdSpotConfig().then(() => {
          updateColdSpotUI();
          loadCcsData();
        });
      } else {
        activeDashConfig = DASH_CONFIGS.efficiency;
        ddCycle.style.display = '';
        ddEfficiency.style.display = '';
        rejSettingsBtn.style.display = 'none';
        // maToggleBtn visibility is controlled by cycle type selection
        heatmapArea.style.display = 'block';
        loadData();
      }
    }

    function switchKpiMode(mode) {
      kpiMode = mode;
      document.querySelectorAll('.kpi-toggle-btn.best, .kpi-toggle-btn.worst').forEach(b => b.classList.remove('active'));
      document.querySelector(`.kpi-toggle-btn.${mode}`).classList.add('active');
      renderKpi();
    }

    function switchKpiDataType(type) {
      kpiDataType = type;
      document.querySelectorAll('.kpi-toggle-btn.efficiency, .kpi-toggle-btn.rejections').forEach(b => b.classList.remove('active'));
      document.querySelector(`.kpi-toggle-btn.${type}`).classList.add('active');
      renderKpi();
    }

    async function loadKpiData() {
      document.getElementById('kpi-loading').style.display = 'block';
      document.getElementById('kpi-content').style.display = 'none';

      buildDeviceMap();
      if (!state.authToken) {
        state.authToken = 'Bearer ' + CONFIG.fallbackAuth;
      }

      const now = new Date();
      const endMs = now.getTime();
      const startDate = new Date(now);
      startDate.setDate(startDate.getDate() - 45);
      const startMs = startDate.getTime();

      const cellRange = getCellRange();
      const cellNums = [];
      for (let i = cellRange.start; i <= cellRange.end; i++) cellNums.push(i);

      const kpiRaw = {};
      const kpiRejRaw = {};
      const tasks = [];
      let loadedCount = 0;
      const totalTasks = cellNums.length * 4; // 2 for efficiency + 2 for rejection

      cellNums.forEach(cellNum => {
        const dev = state.deviceMap[cellNum];
        if (!dev) return;

        // Efficiency sensors (D5, D11)
        tasks.push(async () => {
          const data = await fetchSensorData(dev.devID, CONFIG.sensorC1, startMs, endMs);
          loadedCount++;
          document.getElementById('kpi-loading').textContent = `Loading...`;
          return { cellNum, sensor: 'C1', data, type: 'efficiency' };
        });

        tasks.push(async () => {
          const data = await fetchSensorData(dev.devID, CONFIG.sensorC2, startMs, endMs);
          loadedCount++;
          document.getElementById('kpi-loading').textContent = `Loading...`;
          return { cellNum, sensor: 'C2', data, type: 'efficiency' };
        });

        // Rejection sensors (D1, D7)
        tasks.push(async () => {
          const data = await fetchSensorData(dev.devID, 'D1', startMs, endMs);
          loadedCount++;
          document.getElementById('kpi-loading').textContent = `Loading...`;
          return { cellNum, sensor: 'C1', data, type: 'rejection' };
        });

        tasks.push(async () => {
          const data = await fetchSensorData(dev.devID, 'D7', startMs, endMs);
          loadedCount++;
          document.getElementById('kpi-loading').textContent = `Loading...`;
          return { cellNum, sensor: 'C2', data, type: 'rejection' };
        });
      });

      const results = await runWithConcurrency(tasks, CONFIG.concurrency);

      state.cellData = {};
      state.rejectionData = {};

      results.forEach(r => {
        if (!r) return;
        const key = `${r.cellNum}-${r.sensor}`;
        const byDate = {};
        if (r.data && r.data.length) {
          r.data.forEach(dp => {
            if (dp && dp.time && dp.value !== undefined && dp.value !== null) {
              const d = new Date(dp.time);
              const dk = formatDateKey(d);
              const val = parseFloat(dp.value);
              if (!isNaN(val)) {
                if (!byDate[dk] || new Date(dp.time) > new Date(byDate[dk].time)) {
                  byDate[dk] = { value: val, time: dp.time };
                }
              }
            }
          });
        }
        const sortedDates = Object.keys(byDate).sort().reverse();
        const values = sortedDates.map(dk => Math.round(byDate[dk].value * 100) / 100);

        // Store in appropriate data structure based on type
        if (r.type === 'rejection') {
          kpiRejRaw[key] = values;
          // Store rejection data in state.rejectionData for chart functionality
          if (!state.rejectionData[r.cellNum]) state.rejectionData[r.cellNum] = {};
          const dateValues = {};
          Object.keys(byDate).forEach(dk => { dateValues[dk] = Math.round(byDate[dk].value * 100) / 100; });
          state.rejectionData[r.cellNum][r.sensor] = dateValues;
        } else {
          kpiRaw[key] = values;
          // Store efficiency data in state.cellData for existing chart functionality
          if (!state.cellData[r.cellNum]) state.cellData[r.cellNum] = {};
          const dateValues = {};
          Object.keys(byDate).forEach(dk => { dateValues[dk] = Math.round(byDate[dk].value * 100) / 100; });
          state.cellData[r.cellNum][r.sensor] = dateValues;
        }
      });

      // Process efficiency data
      kpiData = {};
      [3, 7, 30].forEach(n => {
        const entries = [];
        Object.keys(kpiRaw).forEach(key => {
          const vals = kpiRaw[key];
          const slice = vals.slice(0, n);
          if (slice.length === 0) {
            entries.push({ key, avg: null });
          } else {
            const avg = Math.round((slice.reduce((a, b) => a + b, 0) / slice.length) * 100) / 100;
            entries.push({ key, avg });
          }
        });
        kpiData[n] = entries;
      });

      // Process rejection data (average instead of total)
      kpiRejectionData = {};
      [3, 7, 30].forEach(n => {
        const entries = [];
        Object.keys(kpiRejRaw).forEach(key => {
          const vals = kpiRejRaw[key];
          const slice = vals.slice(0, n);
          if (slice.length === 0) {
            entries.push({ key, avg: null });
          } else {
            const avg = Math.round((slice.reduce((a, b) => a + b, 0) / slice.length) * 100) / 100;
            entries.push({ key, avg });
          }
        });
        kpiRejectionData[n] = entries;
      });

      kpiDataLoaded = true;
      document.getElementById('kpi-loading').style.display = 'none';
      document.getElementById('kpi-content').style.display = 'grid';
      renderKpi();
    }

    function getBarClass(val) {
      if (val >= state.thresholds.excellent.min) return 'bar-excellent';
      if (val >= state.thresholds.good.min) return 'bar-good';
      return 'bar-bad';
    }
    function getPctClass(val) {
      if (val >= state.thresholds.excellent.min) return 'pct-excellent';
      if (val >= state.thresholds.good.min) return 'pct-good';
      return 'pct-bad';
    }

    // Rejection bar/pct classes (inverse logic: lower is better)
    function getRejBarClass(val) {
      const rt = state.rejThresholds;
      if (val <= rt.excellent) return 'bar-excellent';
      if (val <= rt.good) return 'bar-good';
      return 'bar-bad';
    }
    function getRejPctClass(val) {
      const rt = state.rejThresholds;
      if (val <= rt.excellent) return 'pct-excellent';
      if (val <= rt.good) return 'pct-good';
      return 'pct-bad';
    }

    function parseCellKey(key) {
      const parts = key.split('-');
      return { num: parseInt(parts[0]), sensor: parts[1] };
    }

    function sortCellKeys(a, b) {
      const pa = parseCellKey(a.key), pb = parseCellKey(b.key);
      if (pa.num !== pb.num) return pa.num - pb.num;
      return pa.sensor < pb.sensor ? -1 : 1;
    }

    function renderKpi() {
      // Update column titles and headers based on data type
      const isRejection = kpiDataType === 'rejections';

      [3, 7, 30].forEach(n => {
        // Update column title
        const colTitle = document.querySelector(`#kpi-col-${n}`).previousElementSibling.previousElementSibling;
        if (isRejection) {
          colTitle.textContent = `Last ${n} Cycles Avg Rejections`;
        } else {
          colTitle.textContent = `Last ${n} Cycles Avg Efficiency`;
        }

        // Update table header
        const tableHeader = document.querySelector(`#kpi-col-${n}`).previousElementSibling;
        if (isRejection) {
          tableHeader.innerHTML = '<span>Cell No</span><span class="kpi-hdr-eff">Rejected Cathodes</span><span>Avg</span>';
        } else {
          tableHeader.innerHTML = '<span>Cell No</span><span class="kpi-hdr-eff">Avg Efficiency</span><span>CE%</span>';
        }
      });

      // Render data based on type
      if (isRejection) {
        renderKpiRejections();
      } else {
        renderKpiEfficiency();
      }
    }

    function renderKpiEfficiency() {
      if (!kpiData) return;

      [3, 7, 30].forEach(n => {
        const container = document.getElementById(`kpi-col-${n}`);
        const entries = kpiData[n].filter(e => e.avg !== null);

        if (kpiMode === 'best') {
          // Best: highest efficiency first (descending)
          entries.sort((a, b) => b.avg - a.avg);
        } else {
          // Worst: lowest efficiency first (ascending)
          entries.sort((a, b) => a.avg - b.avg);
        }

        const top10 = entries.slice(0, 10);
        // Don't re-sort - keep in performance order

        if (top10.length === 0) {
          container.innerHTML = '<div class="kpi-nodata">No data available</div>';
          return;
        }

        let html = '';
        top10.forEach(item => {
          const p = parseCellKey(item.key);
          const cellLabel = `${p.num}-${p.sensor}`;
          const barW = Math.max(item.avg, 0);
          const barClass = getBarClass(item.avg);
          const pctClass = getPctClass(item.avg);
          html += `<div class="kpi-row" onclick="openKpiCellChart(${p.num},'${p.sensor}')" style="cursor:pointer;">
            <div class="kpi-cell-label" style="color:var(--primary-dark);text-decoration:underline;text-underline-offset:2px;">${cellLabel}</div>
            <div class="kpi-bar-wrap"><div class="kpi-bar ${barClass}" style="width:${barW}%"></div></div>
            <div class="kpi-pct ${pctClass}">${Math.round(item.avg)}%</div>
          </div>`;
        });
        container.innerHTML = html;
      });
    }

    function renderKpiRejections() {
      if (!kpiRejectionData) return;

      [3, 7, 30].forEach(n => {
        const container = document.getElementById(`kpi-col-${n}`);
        const entries = kpiRejectionData[n].filter(e => e.avg !== null);

        if (kpiMode === 'best') {
          // Best: lowest rejections first (ascending)
          entries.sort((a, b) => a.avg - b.avg);
        } else {
          // Worst: highest rejections first (descending)
          entries.sort((a, b) => b.avg - a.avg);
        }

        const top10 = entries.slice(0, 10);
        // Don't re-sort - keep in performance order

        if (top10.length === 0) {
          container.innerHTML = '<div class="kpi-nodata">No data available</div>';
          return;
        }

        // Find max value for bar width scaling
        const maxVal = Math.max(...top10.map(item => item.avg));

        let html = '';
        top10.forEach(item => {
          const p = parseCellKey(item.key);
          const cellLabel = `${p.num}-${p.sensor}`;
          const barW = maxVal > 0 ? (item.avg / maxVal) * 100 : 0;
          const barClass = getRejBarClass(item.avg);
          const pctClass = getRejPctClass(item.avg);
          html += `<div class="kpi-row" onclick="openKpiRejectionChart(${p.num},'${p.sensor}')" style="cursor:pointer;">
            <div class="kpi-cell-label" style="color:var(--primary-dark);text-decoration:underline;text-underline-offset:2px;">${cellLabel}</div>
            <div class="kpi-bar-wrap"><div class="kpi-bar ${barClass}" style="width:${barW}%"></div></div>
            <div class="kpi-pct ${pctClass}">${item.avg}</div>
          </div>`;
        });
        container.innerHTML = html;
      });
    }

    function toggleKpiExportMenu() {
      document.getElementById('kpiExportMenu').classList.toggle('show');
    }
    document.addEventListener('click', e => {
      if (!e.target.closest('#kpiExportDropdown')) {
        const m = document.getElementById('kpiExportMenu');
        if (m) m.classList.remove('show');
      }
    });

    function getKpiTop10(n) {
      if (kpiDataType === 'rejections') {
        const entries = kpiRejectionData[n].filter(e => e.avg !== null);
        if (kpiMode === 'best') entries.sort((a, b) => a.avg - b.avg); // ascending
        else entries.sort((a, b) => b.avg - a.avg); // descending
        const top10 = entries.slice(0, 10);
        top10.sort(sortCellKeys);
        return top10;
      } else {
        const entries = kpiData[n].filter(e => e.avg !== null);
        if (kpiMode === 'best') entries.sort((a, b) => b.avg - a.avg);
        else entries.sort((a, b) => a.avg - b.avg);
        const top10 = entries.slice(0, 10);
        top10.sort(sortCellKeys);
        return top10;
      }
    }

    function kpiCellColor(val) {
      if (kpiDataType === 'rejections') {
        const rt = state.rejThresholds;
        if (val <= rt.excellent) return { bg: '#DCFCE7', text: '#16A34A' };
        if (val <= rt.good) return { bg: '#FFF7ED', text: '#EA580C' };
        return { bg: '#FEF2F2', text: '#DC2626' };
      } else {
        if (val >= state.thresholds.excellent.min) return { bg: '#DCFCE7', text: '#16A34A' };
        if (val >= state.thresholds.good.min) return { bg: '#FFF7ED', text: '#EA580C' };
        return { bg: '#FEF2F2', text: '#DC2626' };
      }
    }

    function buildKpiExportTable() {
      const isRejection = kpiDataType === 'rejections';
      if (isRejection && !kpiRejectionData) return '';
      if (!isRejection && !kpiData) return '';

      const modeLabel = kpiMode === 'best' ? 'Top 10 Best Cell' : 'Top 10 Worst Cell';
      const sideLabel = state.currentSide === 'east' ? 'East Side CSM 2' : 'West Side';
      const cols = [3, 7, 30];
      const colData = {};
      cols.forEach(n => { colData[n] = getKpiTop10(n); });

      const totalCols = 8;
      const bdr = 'border:1px solid #B0BEC5;';
      const ff = 'font-family:Inter,Calibri,Arial,sans-serif;';

      let html = `<table style="border-collapse:collapse;">`;

      // Main header: Cell Efficiency Monitoring
      html += `<tr><td colspan="${totalCols}" style="${bdr}${ff}background:#0F172A;color:#FFFFFF;text-align:center;font-size:16px;font-weight:700;padding:12px 8px;letter-spacing:0.5px;">Cell Efficiency Monitoring</td></tr>`;

      // Sub-header with dashboard context
      const dataTypeLabel = isRejection ? 'Rejected Cathodes' : 'Cell Efficiency';
      const subtitle = `KPI Dashboard | ${dataTypeLabel} | ${modeLabel} | ${sideLabel}`;
      html += `<tr><td colspan="${totalCols}" style="${bdr}${ff}background:#1E3A5F;color:#FFFFFF;text-align:center;font-size:14px;font-weight:600;padding:10px 8px;">${subtitle}</td></tr>`;

      // Duration line
      const duration = getFormattedDuration('kpi');
      html += `<tr><td colspan="${totalCols}" style="${bdr}${ff}background:#F0F4F8;color:#4A5568;text-align:center;font-size:12px;font-weight:500;padding:8px 6px;">${duration}</td></tr>`;

      // Empty row for spacing
      html += `<tr><td colspan="${totalCols}" style="height:8px;border:none;background:#FFFFFF;"></td></tr>`;

      html += `<tr>`;
      cols.forEach((n, ci) => {
        const colTitle = isRejection ? `Last ${n} Cycles Avg Rejections` : `Last ${n} Cycles Avg Efficiency`;
        html += `<th colspan="2" style="${bdr}${ff}background:#37474F;color:#FFFFFF;text-align:center;font-size:13px;font-weight:700;padding:10px 8px;">${colTitle}</th>`;
        if (ci < 2) html += `<td style="border:none;width:12px;background:#FFFFFF;"></td>`;
      });
      html += `</tr>`;

      html += `<tr>`;
      cols.forEach((_, ci) => {
        html += `<th style="${bdr}${ff}background:#546E7A;color:#FFFFFF;text-align:center;font-size:11px;font-weight:600;padding:8px 6px;width:90px;">Cell No</th>`;
        const valueHeader = isRejection ? 'Avg' : 'CE%';
        html += `<th style="${bdr}${ff}background:#546E7A;color:#FFFFFF;text-align:center;font-size:11px;font-weight:600;padding:8px 6px;width:90px;">${valueHeader}</th>`;
        if (ci < 2) html += `<td style="border:none;width:12px;background:#FFFFFF;"></td>`;
      });
      html += `</tr>`;

      for (let i = 0; i < 10; i++) {
        const rowBg = i % 2 === 0 ? '#FFFFFF' : '#F5F7FA';
        html += `<tr>`;
        cols.forEach((n, ci) => {
          const item = colData[n][i];
          if (item) {
            const p = parseCellKey(item.key);
            const cellLabel = `${p.num}-${p.sensor}`;
            const value = item.avg;
            const c = kpiCellColor(value);
            const displayValue = isRejection ? value : `${value}%`;
            html += `<td style="${bdr}${ff}background:${rowBg};text-align:center;font-size:12px;font-weight:700;padding:7px 6px;color:#1E3A5F;">${cellLabel}</td>`;
            html += `<td style="${bdr}${ff}background:${c.bg};text-align:center;font-size:13px;font-weight:800;padding:7px 6px;color:${c.text};">${displayValue}</td>`;
          } else {
            html += `<td style="${bdr}${ff}background:${rowBg};text-align:center;padding:7px 6px;">--</td>`;
            html += `<td style="${bdr}${ff}background:${rowBg};text-align:center;padding:7px 6px;">--</td>`;
          }
          if (ci < 2) html += `<td style="border:none;width:12px;background:#FFFFFF;"></td>`;
        });
        html += `</tr>`;
      }

      html += `</table>`;
      return html;
    }

    function exportKpiExcel() {
      document.getElementById('kpiExportMenu').classList.remove('show');
      const isRejection = kpiDataType === 'rejections';
      if (isRejection && !kpiRejectionData) return;
      if (!isRejection && !kpiData) return;

      const htmlTable = buildKpiExportTable();
      const modeLabel = kpiMode === 'best' ? 'Top_10_Best' : 'Top_10_Worst';
      const side = state.currentSide === 'east' ? 'East_Side' : 'West_Side';
      const dataType = isRejection ? 'Rejected_Cathodes' : 'Cell_Efficiency';
      const fileName = `KPI_${dataType}_${modeLabel}_${side}_${new Date().toISOString().slice(0,10)}.xls`;

      const excelHtml = `
        <html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel">
        <head><meta charset="utf-8">
        <!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet>
        <x:Name>KPI</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions>
        </x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]-->
        </head><body>${htmlTable}</body></html>`;

      const blob = new Blob([excelHtml], { type: 'application/vnd.ms-excel' });
      const link = document.createElement('a');
      link.download = fileName;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function exportKpiImage() {
      document.getElementById('kpiExportMenu').classList.remove('show');
      const isRejection = kpiDataType === 'rejections';
      if (isRejection && !kpiRejectionData) return;
      if (!isRejection && !kpiData) return;

      const modeLabel = kpiMode === 'best' ? 'Top 10 Best Cell' : 'Top 10 Worst Cell';
      const sideLabel = state.currentSide === 'east' ? 'East Side - CSM 2' : 'West Side';
      const cols = [3, 7, 30];
      const colData = {};
      cols.forEach(n => { colData[n] = getKpiTop10(n); });

      const scale = 2;
      const colWidth = 320;
      const colGap = 20;
      const titleH = 40;
      const subtitleH = 30;
      const headerH = titleH + subtitleH;
      const subHeaderH = 36;
      const rowH = 32;
      const padX = 30;
      const padY = 20;
      const totalW = padX * 2 + colWidth * 3 + colGap * 2;
      const totalH = padY + headerH + subHeaderH + rowH * 11 + padY;

      const canvas = document.createElement('canvas');
      canvas.width = totalW * scale;
      canvas.height = totalH * scale;
      const ctx = canvas.getContext('2d');
      ctx.scale(scale, scale);

      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, totalW, totalH);

      const mainTitle = isRejection ? 'KPI Rejected Cathodes' : 'KPI Dashboard';
      ctx.fillStyle = '#1E3A5F';
      ctx.fillRect(0, 0, totalW, titleH);
      ctx.fillStyle = '#FFFFFF';
      ctx.font = '700 16px Inter, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`${mainTitle} - ${sideLabel}`, totalW / 2, titleH / 2 + 6);

      ctx.fillStyle = '#2D5F8A';
      ctx.fillRect(0, titleH, totalW, subtitleH);
      ctx.fillStyle = '#FFFFFF';
      ctx.font = '600 13px Inter, Arial, sans-serif';
      ctx.fillText(modeLabel, totalW / 2, titleH + subtitleH / 2 + 5);

      cols.forEach((n, ci) => {
        const x = padX + ci * (colWidth + colGap);
        const y = headerH;

        const colTitle = isRejection ? `Last ${n} Cycles Total Rejections` : `Last ${n} Cycles Avg Efficiency`;
        ctx.fillStyle = '#E5E7EB';
        ctx.fillRect(x, y, colWidth, subHeaderH);
        ctx.strokeStyle = '#D1D5DB';
        ctx.strokeRect(x, y, colWidth, subHeaderH);
        ctx.fillStyle = '#1F2937';
        ctx.font = '700 13px Inter, Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(colTitle, x + colWidth / 2, y + subHeaderH / 2 + 5);

        const cellW = 70;
        const barW = colWidth - cellW - 60;
        const pctW = 60;

        const valueLabel = isRejection ? 'Total' : 'CE%';
        const middleLabel = isRejection ? 'Rejected Cathodes' : 'Avg Efficiency';
        ctx.fillStyle = '#F3F4F6';
        ctx.fillRect(x, y + subHeaderH, colWidth, rowH);
        ctx.strokeRect(x, y + subHeaderH, colWidth, rowH);
        ctx.fillStyle = '#374151';
        ctx.font = '600 11px Inter, Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Cell No', x + cellW / 2, y + subHeaderH + rowH / 2 + 4);
        ctx.fillText(middleLabel, x + cellW + barW / 2, y + subHeaderH + rowH / 2 + 4);
        ctx.fillText(valueLabel, x + cellW + barW + pctW / 2, y + subHeaderH + rowH / 2 + 4);

        const data = colData[n];
        for (let i = 0; i < 10; i++) {
          const ry = y + subHeaderH + rowH + i * rowH;

          ctx.fillStyle = i % 2 === 0 ? '#FFFFFF' : '#F9FAFB';
          ctx.fillRect(x, ry, colWidth, rowH);
          ctx.strokeStyle = '#E5E7EB';
          ctx.strokeRect(x, ry, colWidth, rowH);

          if (data[i]) {
            const item = data[i];
            const p = parseCellKey(item.key);
            const value = item.avg;
            const c = kpiCellColor(value);

            ctx.fillStyle = '#1E3A5F';
            ctx.font = '600 11px Inter, Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${p.num}-${p.sensor}`, x + cellW / 2, ry + rowH / 2 + 4);

            const barX = x + cellW + 4;
            const barY = ry + 8;
            const barH = rowH - 16;
            const maxBarW = barW - 8;
            ctx.fillStyle = '#E5E7EB';
            roundRect(ctx, barX, barY, maxBarW, barH, 3);
            ctx.fill();

            // Calculate bar width based on data type
            let filledW;
            if (isRejection) {
              // For rejections, find max in this column and scale proportionally
              const maxInCol = Math.max(...data.filter(d => d).map(d => d.total));
              filledW = maxInCol > 0 ? (value / maxInCol) * maxBarW : 0;
            } else {
              filledW = Math.max((value / 100) * maxBarW, 0);
            }
            ctx.fillStyle = c.text;
            roundRect(ctx, barX, barY, filledW, barH, 3);
            ctx.fill();

            ctx.fillStyle = c.bg;
            ctx.fillRect(x + cellW + barW, ry, pctW, rowH);
            ctx.strokeStyle = '#E5E7EB';
            ctx.strokeRect(x + cellW + barW, ry, pctW, rowH);
            ctx.fillStyle = c.text;
            ctx.font = '700 12px Inter, Arial, sans-serif';
            ctx.textAlign = 'center';
            const displayValue = isRejection ? value : `${Math.round(value)}%`;
            ctx.fillText(displayValue, x + cellW + barW + pctW / 2, ry + rowH / 2 + 4);
          } else {
            ctx.fillStyle = '#9CA3AF';
            ctx.font = '600 11px Inter, Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('--', x + colWidth / 2, ry + rowH / 2 + 4);
          }
        }
      });

      const link = document.createElement('a');
      const side = state.currentSide === 'east' ? 'East_Side' : 'West_Side';
      const mode = kpiMode === 'best' ? 'Top_10_Best' : 'Top_10_Worst';
      const dataType = isRejection ? 'Rejected_Cathodes' : 'Cell_Efficiency';
      link.download = `KPI_${dataType}_${mode}_${side}_${new Date().toISOString().slice(0,10)}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    /* ================================================
       CELL CYCLE SUMMARY DASHBOARD
       ================================================ */

    // Cold Spot Cathodes - Default Thresholds (configurable)
    const COLD_SPOT_DEFAULTS = {
      coldSpot: 90,        // Pre-stripping weight < 90 kg
      singleSideMin: 60,   // Single side cold: 60 < weight  90 kg
      singleSideMax: 90,
      doubleSide: 60       // Double side cold: weight  60 kg
    };

    // Current cold spot thresholds (will be loaded from IOsense SDK)
    let coldSpotThresholds = { ...COLD_SPOT_DEFAULTS };
    let coldSpotConfigId = null; // Store config ID for updates

    /**
     * Load Cold Spot Configuration from IOsense SDK
     * Uses getUserConfigByType API to retrieve saved thresholds
     */
    async function loadColdSpotConfig() {
      try {
        console.log(' Loading cold spot configuration from IOsense...');
        const authVal = state.authToken?.startsWith('Bearer ') ? state.authToken : 'Bearer ' + state.authToken;

        const res = await fetch(CONFIG.apiBase + '/account/processFlow/byType/AISDK', {
          method: 'GET',
          headers: {
            'Authorization': authVal,
            'Content-Type': 'application/json'
          }
        });

        const data = await res.json();
        if (data.success && data.data && data.data.config && data.data.config.thresholds) {
          coldSpotThresholds = data.data.config.thresholds;
          coldSpotConfigId = data.data._id;
          console.log(' Loaded cold spot config:', coldSpotThresholds);
          return true;
        } else {
          console.log('  No saved config found, using defaults');
          coldSpotThresholds = { ...COLD_SPOT_DEFAULTS };
          return false;
        }
      } catch (e) {
        console.warn(' Error loading cold spot config:', e);
        coldSpotThresholds = { ...COLD_SPOT_DEFAULTS };
        return false;
      }
    }

    /**
     * Save Cold Spot Configuration to IOsense SDK
     * Uses addUserConfig (first time) or updateUserConfig (subsequent saves)
     */
    async function saveColdSpotConfig(thresholds) {
      try {
        console.log(' Saving cold spot configuration to IOsense...');
        const authVal = state.authToken?.startsWith('Bearer ') ? state.authToken : 'Bearer ' + state.authToken;

        const configData = {
          title: "HZL Cell Monitoring Cold Spot Config",
          description: "Threshold configuration for cold spot cathode detection",
          configType: "AISDK",
          config: {
            thresholds: thresholds,
            lastUpdated: new Date().toISOString()
          },
          autoRefresh: false,
          autoRefreshTimeout: 0,
          reloadActive: false
        };

        let res;
        if (coldSpotConfigId) {
          // Update existing configuration
          res = await fetch(CONFIG.apiBase + '/account/userConfig/' + coldSpotConfigId, {
            method: 'PUT',
            headers: {
              'Authorization': authVal,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(configData)
          });
        } else {
          // Create new configuration
          res = await fetch(CONFIG.apiBase + '/account/userConfig', {
            method: 'POST',
            headers: {
              'Authorization': authVal,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(configData)
          });
        }

        const data = await res.json();
        if (data.success && data.data) {
          coldSpotThresholds = thresholds;
          coldSpotConfigId = data.data._id;
          console.log(' Cold spot configuration saved successfully');
          return true;
        } else {
          console.warn(' Failed to save config:', data);
          return false;
        }
      } catch (e) {
        console.error(' Error saving cold spot config:', e);
        return false;
      }
    }

    const CCS_CONFIG = {
      devID: 'HZLCCSMR_A2',
      sensors: {
        cellNumber:    'D2',
        cellSelection: 'D3',
        cycleStart:    'D11',
        cycleEnd:      'D12',
        cycleTime:     'D13',
        numCathodes:   'D4',
        goodCathodes:  'D5',
        badCathodes:   'D6',
        sumGoodWeight: 'D7',
        weight57:      'D10',
        busbarLoad:    'D14',
        ce:            'D16'
      },
      columns: [
        { key: 'cellNumber',    label: 'Cell Number' },
        { key: 'cellSelection', label: 'Cell Selection' },
        { key: 'cycleStart',    label: 'Cycle Start Time' },
        { key: 'cycleEnd',      label: 'Cycle End Time' },
        { key: 'cycleTime',     label: 'Cycle Time (hrs)' },
        { key: 'numCathodes',   label: 'No of Cathodes' },
        { key: 'goodCathodes',  label: 'Good Cathodes' },
        { key: 'badCathodes',   label: 'Bad Cathodes' },
        { key: 'coldSpotCathodes', label: 'No of Cold Spot Cathodes' },
        { key: 'sumGoodWeight', label: 'Sum Wt of Good Cathodes' },
        { key: 'weight57',      label: 'Wt of 57 Cathodes' },
        { key: 'busbarLoad',    label: 'Bus Bar Load' },
        { key: 'ce',            label: 'CE (%)' }
      ]
    };

    let ccsState = {
      timePeriod: 'thisWeek',
      customStart: null,
      customEnd: null,
      rows: [],
      totalCount: 0,
      serverTotalCount: 0, // Total count from server
      page: 1,
      pageSize: 50,
      filters: { cellNumber: null, cellSelection: null },
      sortCol: null,
      sortDir: null,
      loadedPages: new Set(), // Track which pages we've loaded from server
      isLoadingMore: false // Flag to prevent concurrent loads
    };

    function getCcsDateRange() {
      const now = new Date();
      let start, end;
      switch (ccsState.timePeriod) {
        case 'thisWeek': {
          const day = now.getDay();
          start = new Date(now); start.setDate(now.getDate() - (day === 0 ? 6 : day - 1));
          start.setHours(0,0,0,0);
          end = new Date(now); end.setHours(23,59,59,999);
          break;
        }
        case 'lastWeek': {
          const day = now.getDay();
          const thisMonday = new Date(now); thisMonday.setDate(now.getDate() - (day === 0 ? 6 : day - 1));
          end = new Date(thisMonday); end.setDate(end.getDate() - 1); end.setHours(23,59,59,999);
          start = new Date(end); start.setDate(start.getDate() - 6); start.setHours(0,0,0,0);
          break;
        }
        case 'thisMonth':
          start = new Date(now.getFullYear(), now.getMonth(), 1);
          end = new Date(now); end.setHours(23,59,59,999);
          break;
        case 'lastMonth':
          start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          end = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
          break;
        case 'custom':
          start = ccsState.customStart ? new Date(ccsState.customStart) : new Date(now.getFullYear(), now.getMonth(), 1);
          end = ccsState.customEnd ? new Date(ccsState.customEnd + 'T23:59:59.999') : new Date(now);
          start.setHours(0,0,0,0);
          break;
        default:
          start = new Date(now); start.setDate(start.getDate() - 6); start.setHours(0,0,0,0);
          end = new Date(now); end.setHours(23,59,59,999);
      }
      return { start, end };
    }

    function selectCcsTime(item) {
      const dd = document.getElementById('dd-ccs-time');
      dd.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('active'));
      item.classList.add('active');
      dd.querySelector('.dropdown-label').textContent = item.textContent;
      closeAllDropdowns();
      ccsState.timePeriod = item.dataset.value;
      const customRange = document.getElementById('ccs-custom-date-range');
      if (ccsState.timePeriod === 'custom') {
        customRange.style.display = 'flex';
        customRange.style.alignItems = 'center';
        customRange.style.gap = '8px';
        return;
      }
      customRange.style.display = 'none';
      loadCcsData();
    }

    function applyCcsCustomDates() {
      ccsState.customStart = document.getElementById('ccsCustomStart').value;
      ccsState.customEnd = document.getElementById('ccsCustomEnd').value;
      if (!ccsState.customStart || !ccsState.customEnd) return;
      loadCcsData();
    }

    /**
     * Open Cold Spot Settings Modal
     */
    function openColdSpotSettings() {
      updateColdSpotUI();
      document.getElementById('cold-spot-settings-modal').classList.add('show');
      document.getElementById('coldSpotConfigMessage').style.display = 'none';
    }

    /**
     * Close Cold Spot Settings Modal
     */
    function closeColdSpotSettings() {
      document.getElementById('cold-spot-settings-modal').classList.remove('show');
    }

    /**
     * Reset Cold Spot thresholds to defaults
     */
    function resetColdSpotDefaults() {
      document.getElementById('coldSpotInput').value = COLD_SPOT_DEFAULTS.coldSpot;
      document.getElementById('singleSideMinInput').value = COLD_SPOT_DEFAULTS.singleSideMin;
      document.getElementById('singleSideMaxInput').value = COLD_SPOT_DEFAULTS.singleSideMax;
      document.getElementById('doubleSideInput').value = COLD_SPOT_DEFAULTS.doubleSide;
    }

    /**
     * Update Cold Spot Configuration UI with current values
     */
    function updateColdSpotUI() {
      document.getElementById('coldSpotInput').value = coldSpotThresholds.coldSpot;
      document.getElementById('singleSideMinInput').value = coldSpotThresholds.singleSideMin;
      document.getElementById('singleSideMaxInput').value = coldSpotThresholds.singleSideMax;
      document.getElementById('doubleSideInput').value = coldSpotThresholds.doubleSide;
    }

    /**
     * Apply Cold Spot Configuration
     * Validates inputs, saves to IOsense SDK, and reloads data
     */
    async function applyColdSpotConfig() {
      const msgEl = document.getElementById('coldSpotConfigMessage');
      msgEl.style.display = 'none';

      // Get input values
      const coldSpot = parseFloat(document.getElementById('coldSpotInput').value);
      const singleSideMin = parseFloat(document.getElementById('singleSideMinInput').value);
      const singleSideMax = parseFloat(document.getElementById('singleSideMaxInput').value);
      const doubleSide = parseFloat(document.getElementById('doubleSideInput').value);

      // Validation with warnings (use defaults for invalid)
      const warnings = [];
      const newThresholds = { ...COLD_SPOT_DEFAULTS };

      if (isNaN(coldSpot) || coldSpot <= 0) {
        warnings.push('Cold Spot value invalid, using default (90)');
        newThresholds.coldSpot = COLD_SPOT_DEFAULTS.coldSpot;
      } else {
        newThresholds.coldSpot = coldSpot;
      }

      if (isNaN(singleSideMin) || singleSideMin <= 0) {
        warnings.push('Single Side Min invalid, using default (60)');
        newThresholds.singleSideMin = COLD_SPOT_DEFAULTS.singleSideMin;
      } else {
        newThresholds.singleSideMin = singleSideMin;
      }

      if (isNaN(singleSideMax) || singleSideMax <= 0) {
        warnings.push('Single Side Max invalid, using default (90)');
        newThresholds.singleSideMax = COLD_SPOT_DEFAULTS.singleSideMax;
      } else {
        newThresholds.singleSideMax = singleSideMax;
      }

      if (newThresholds.singleSideMin >= newThresholds.singleSideMax) {
        warnings.push('Single Side Min must be < Max, using defaults');
        newThresholds.singleSideMin = COLD_SPOT_DEFAULTS.singleSideMin;
        newThresholds.singleSideMax = COLD_SPOT_DEFAULTS.singleSideMax;
      }

      if (isNaN(doubleSide) || doubleSide <= 0) {
        warnings.push('Double Side value invalid, using default (60)');
        newThresholds.doubleSide = COLD_SPOT_DEFAULTS.doubleSide;
      } else {
        newThresholds.doubleSide = doubleSide;
      }

      // Show warnings if any
      if (warnings.length > 0) {
        msgEl.textContent = '  ' + warnings.join('; ');
        msgEl.style.display = 'block';
        msgEl.style.color = '#EA580C'; // Warning color
      }

      // Save configuration to IOsense SDK
      const saved = await saveColdSpotConfig(newThresholds);
      if (saved) {
        msgEl.textContent = ' Configuration saved successfully!';
        msgEl.style.display = 'block';
        msgEl.style.color = '#16A34A'; // Success color
        msgEl.style.background = '#DCFCE7';
        msgEl.style.border = '1px solid #22C55E';

        // Update UI to show saved values
        updateColdSpotUI();

        // Reload data with new thresholds
        await loadCcsData();

        // Close modal after 1 second
        setTimeout(() => {
          closeColdSpotSettings();
        }, 1000);
      } else {
        msgEl.textContent = ' Failed to save configuration';
        msgEl.style.display = 'block';
        msgEl.style.color = '#DC2626'; // Error color
        msgEl.style.background = '#FEE2E2';
        msgEl.style.border = '1px solid #EF4444';
      }
    }

    // Function to load a specific page of cycle data from the server
    async function loadCcsPageData(serverPage) {
      if (ccsState.loadedPages.has(serverPage) || ccsState.isLoadingMore) {
        return; // Already loaded or currently loading
      }

      ccsState.isLoadingMore = true;

      try {
        const { start, end } = getCcsDateRange();
        const authVal = state.authToken.startsWith('Bearer ') ? state.authToken : 'Bearer ' + state.authToken;
        const eastRange = state.currentSide === 'east' ? [67, 132] : [1, 66];

        const body = {
          devID: CCS_CONFIG.devID,
          page: serverPage,
          limit: ccsState.pageSize, // Use current page size
          rawData: true,
          sort: [{ D12: 'desc' }],
          search: {
            data: {
              D12: [{
                startDate: start.toISOString(),
                endDate: end.toISOString(),
                timeFormat: 'YYYY-MM-DD HH:mm:ss'
              }]
            }
          }
        };

        const ctrl = new AbortController();
        const tid = setTimeout(() => ctrl.abort(), 30000);
        const resp = await fetch(CONFIG.apiBase + '/account/table/getRows3', {
          method: 'PUT',
          headers: {
            'Authorization': authVal,
            'Content-Type': 'application/json',
            'Origin': CONFIG.origin
          },
          body: JSON.stringify(body),
          signal: ctrl.signal
        });
        clearTimeout(tid);
        const result = await resp.json();

        if (result.success && result.data) {
          const rows = result.data.rows || [];
          const newRows = [];

          rows.forEach(r => {
            const d = r.data || {};
            const cellNum = parseInt(d.D2);
            if (isNaN(cellNum)) return;
            if (cellNum < eastRange[0] || cellNum > eastRange[1]) return;

            newRows.push({
              cellNumber: d.D2,
              cellSelection: d.D3,
              cycleStart: d.D11,
              cycleEnd: d.D12,
              cycleTime: d.D13,
              numCathodes: d.D4,
              goodCathodes: d.D5,
              badCathodes: d.D6,
              coldSpotCathodes: 0, // Will be calculated lazily
              sumGoodWeight: d.D7,
              weight57: d.D10,
              busbarLoad: d.D14,
              ce: d.D16,
              time: r.createdAt || d.D12,
              strippingStart: d.D0,
              strippingEnd: d.D19,
              _serverPage: serverPage, // Track which server page this came from
              _serverIndex: (serverPage - 1) * ccsState.pageSize + ccsState.rows.length // Track position
            });
          });

          // Add new rows to state
          ccsState.rows.push(...newRows);
          ccsState.loadedPages.add(serverPage);
          ccsState.serverTotalCount = result.data.totalCount || 0;

          console.log(` Loaded page ${serverPage}: ${newRows.length} rows (total: ${ccsState.rows.length}/${ccsState.serverTotalCount})`);
        }
      } catch (e) {
        console.error(`CCS page ${serverPage} load error:`, e);
      } finally {
        ccsState.isLoadingMore = false;
      }
    }

    async function loadCcsData() {
      if (!state.authToken) {
        await apiLogin();
      }
      const loading = document.getElementById('ccs-loading');
      const tableContainer = document.getElementById('ccs-table-container');
      loading.style.display = 'block';
      tableContainer.style.display = 'none';
      document.getElementById('ccs-loading-text').textContent = 'Loading...';

      // Reset state for fresh load
      ccsState.rows = [];
      ccsState.loadedPages.clear();
      ccsState.serverTotalCount = 0;
      window.allCathodeDataCache = [];

      // Load only the first page
      await loadCcsPageData(1);

      ccsState.totalCount = ccsState.serverTotalCount;
      ccsState.page = 1;
      ccsState.filters = { cellNumber: null, cellSelection: null };
      ccsState.sortCol = null;
      ccsState.sortDir = null;

      // Load cold spot thresholds and cache globally
      const coldSpotThresholds = await loadColdSpotConfig();
      globalColdSpotThresholds = coldSpotThresholds;

      // Fetch cathode data ONLY for the visible rows (first page)
      await loadCathodeDataForVisibleRows();

      loading.style.display = 'none';
      tableContainer.style.display = '';
      renderCcsTable();
    }

    // Function to load cathode data only for currently loaded cycle rows
    async function loadCathodeDataForVisibleRows() {
      if (ccsState.rows.length === 0) return;

      // Use the same date range logic as old version - fetch for entire selected period
      // This ensures we get all cathode data even if timestamps don't align perfectly
      const { start, end } = getCcsDateRange();

      console.log(` Fetching cathode data for date range: ${start.toISOString()}  ${end.toISOString()}`);
      const cathodeData = await fetchAllCathodeData(start, end);
      console.log(` Cathode records fetched: ${cathodeData.length}`);

      // Merge with existing cache or create new
      if (!window.allCathodeDataCache) {
        window.allCathodeDataCache = cathodeData;
      } else {
        // Add new data and remove duplicates
        const existingTimes = new Set(window.allCathodeDataCache.map(c => c.postTime));
        const newData = cathodeData.filter(c => !existingTimes.has(c.postTime));
        window.allCathodeDataCache.push(...newData);
        console.log(` Added ${newData.length} new cathode records to cache`);
      }

      // Pre-populate detail cache for loaded rows (same as old version)
      // This ensures row expansion works immediately without additional API calls
      const coldSpotThresholds = globalColdSpotThresholds || await loadColdSpotConfig();
      ccsState.rows.forEach((row, idx) => {
        const cacheKey = `${row.strippingStart}_${row.strippingEnd}`;

        // Skip if strippingStart is invalid
        if (!row.strippingStart || row.strippingStart === 'null' || row.strippingStart === 'NaT') {
          row.coldSpotCathodes = 0;
          ccsDetailCache[cacheKey] = [];
          return;
        }

        // Filter cathode data for this specific cycle (same logic as old version)
        const cathodeRows = cathodeData.filter(c => {
          try {
            const cathodeTime = new Date(c.postTime).getTime();
            const cycleStart = new Date(row.strippingStart).getTime();
            const cycleEnd = row.strippingEnd ? new Date(row.strippingEnd).getTime() : Date.now();

            if (isNaN(cathodeTime) || isNaN(cycleStart) || isNaN(cycleEnd)) {
              return false;
            }

            return cathodeTime >= cycleStart && cathodeTime <= cycleEnd;
          } catch (e) {
            return false;
          }
        });

        // Limit to 57 rows as per requirements
        if (cathodeRows.length > 57) {
          cathodeRows.splice(57);
        }

        // Calculate cold spot count
        const coldSpotCount = cathodeRows.filter(c => {
          const pw = parseFloat(c.preWeight);
          return !isNaN(pw) && pw < coldSpotThresholds.coldSpot;
        }).length;

        row.coldSpotCathodes = coldSpotCount;
        ccsDetailCache[cacheKey] = cathodeRows; // Pre-populate cache

        // Debug log for first few rows
        if (idx < 3) {
          console.log(`Row ${idx}: Cell ${row.cellNumber} ${row.cellSelection}`);
          console.log(`  Stripping: ${row.strippingStart}  ${row.strippingEnd}`);
          console.log(`  Cathodes found: ${cathodeRows.length}, Cold Spot: ${coldSpotCount}`);
        }
      });
    }

    // Helper function to calculate cold spot cathodes for a single row (lazy calculation)
    function calculateColdSpotForRow(row) {
      const cacheKey = `${row.strippingStart}_${row.strippingEnd}`;

      // If already cached in detail cache, calculate from there
      if (ccsDetailCache[cacheKey]) {
        const coldSpotCount = ccsDetailCache[cacheKey].filter(c => {
          const pw = parseFloat(c.preWeight);
          return !isNaN(pw) && pw < globalColdSpotThresholds.coldSpot;
        }).length;
        row.coldSpotCathodes = coldSpotCount;
        return coldSpotCount;
      }

      // Skip if strippingStart is invalid
      if (!row.strippingStart || row.strippingStart === 'null' || row.strippingStart === 'NaT') {
        row.coldSpotCathodes = 0;
        ccsDetailCache[cacheKey] = [];
        return 0;
      }

      // Calculate from scratch using cached cathode data
      const allCathodeData = window.allCathodeDataCache || [];

      // Determine end time for debug logging
      let debugEndTime;
      if (row.strippingEnd && row.strippingEnd !== 'NaT' && row.strippingEnd !== 'null' && row.strippingEnd !== 'undefined') {
        debugEndTime = row.strippingEnd;
      } else if (row.cycleEnd && row.cycleEnd !== 'NaT' && row.cycleEnd !== 'null') {
        debugEndTime = row.cycleEnd + ' (fallback from cycleEnd)';
      } else {
        debugEndTime = new Date().toISOString() + ' (fallback to current time)';
      }

      // Debug logging for first time
      if (!window._debugCathodeFilter) {
        console.log(` DEBUG: Filtering cathode data for row:`, {
          cellNumber: row.cellNumber,
          cellSelection: row.cellSelection,
          filteringWithStartTime: row.strippingStart,
          filteringWithEndTime: debugEndTime,
          rawCycleStart: row.cycleStart,
          rawCycleEnd: row.cycleEnd,
          rawStrippingStart: row.strippingStart,
          rawStrippingEnd: row.strippingEnd,
          totalCathodeRecords: allCathodeData.length,
          sampleCathode: allCathodeData[0]
        });
        window._debugCathodeFilter = true;
      }

      // Use same filtering logic as old version for consistency
      const cathodeRows = allCathodeData.filter(c => {
        try {
          const cathodeTime = new Date(c.postTime).getTime();
          const cycleStart = new Date(row.strippingStart).getTime();
          const cycleEnd = row.strippingEnd ? new Date(row.strippingEnd).getTime() : Date.now();

          if (isNaN(cathodeTime) || isNaN(cycleStart) || isNaN(cycleEnd)) {
            return false;
          }

          return cathodeTime >= cycleStart && cathodeTime <= cycleEnd;
        } catch (e) {
          return false;
        }
      });

      console.log(` Filtered ${cathodeRows.length} cathodes for cell ${row.cellNumber} (${row.cellSelection})`);

      // Limit to 57 rows as per requirements
      if (cathodeRows.length > 57) {
        console.log(`  Limiting cathode rows from ${cathodeRows.length} to 57`);
        cathodeRows.splice(57);
      }

      // Calculate cold spot count
      const coldSpotCount = cathodeRows.filter(c => {
        const pw = parseFloat(c.preWeight);
        return !isNaN(pw) && pw < globalColdSpotThresholds.coldSpot;
      }).length;

      row.coldSpotCathodes = coldSpotCount;
      ccsDetailCache[cacheKey] = cathodeRows;

      return coldSpotCount;
    }

    function formatCcsDateTime(val) {
      if (!val) return '--';
      const str = String(val);
      if (str.includes('T') || str.includes('-')) {
        const d = new Date(str);
        if (isNaN(d.getTime())) return str;
        const dd = String(d.getDate()).padStart(2, '0');
        const mon = d.toLocaleString('en-US', { month: 'short' });
        const yyyy = d.getFullYear();
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        const ss = String(d.getSeconds()).padStart(2, '0');
        return `${dd}-${mon}-${yyyy} ${hh}:${mm}:${ss}`;
      }
      return str;
    }

    function getCcsFilteredSortedRows() {
      let filtered = ccsState.rows;
      const f = ccsState.filters;
      if (f.cellNumber && f.cellNumber.length > 0) {
        const set = new Set(f.cellNumber.map(Number));
        filtered = filtered.filter(r => set.has(Number(r.cellNumber)));
      }
      if (f.cellSelection && f.cellSelection.length > 0) {
        const set = new Set(f.cellSelection);
        filtered = filtered.filter(r => set.has(r.cellSelection));
      }
      if (ccsState.sortCol && ccsState.sortDir) {
        const key = ccsState.sortCol;
        const dir = ccsState.sortDir === 'asc' ? 1 : -1;
        filtered = [...filtered].sort((a, b) => {
          const va = a[key] !== null && a[key] !== undefined ? parseFloat(a[key]) : NaN;
          const vb = b[key] !== null && b[key] !== undefined ? parseFloat(b[key]) : NaN;
          if (isNaN(va) && isNaN(vb)) return 0;
          if (isNaN(va)) return 1;
          if (isNaN(vb)) return -1;
          return (va - vb) * dir;
        });
      }
      return filtered;
    }

    function getBadCathodeClass(v) {
      const rt = state.rejThresholds;
      if (v <= rt.excellent) return 'rej-excellent';
      if (v <= rt.good) return 'rej-good';
      return 'rej-bad';
    }

    const CCS_FROZEN_COUNT = 3;
    let ccsFrozenLeftCache = [0, 0, 0];

    function renderCcsTable() {
      const thead = document.getElementById('ccs-header');
      const tbody = document.getElementById('ccs-body');
      const cols = CCS_CONFIG.columns;
      const filterCols = ['cellNumber', 'cellSelection'];
      const sortCols = ['cycleTime', 'ce'];

      const frozenCls = (ci) => ci < CCS_FROZEN_COUNT ? 'ccs-frozen' + (ci === CCS_FROZEN_COUNT - 1 ? ' ccs-frozen-last' : '') : '';

      let headerHTML = `<th class="${frozenCls(0)}">#</th>`;
      cols.forEach((c, ci) => {
        const colIdx = ci + 1;
        const isFilter = filterCols.includes(c.key);
        const isSort = sortCols.includes(c.key);
        const fc = frozenCls(colIdx);

        if (!isFilter && !isSort) {
          headerHTML += `<th class="${fc}">${c.label}</th>`;
        } else {
          headerHTML += `<th class="${fc}"><div class="ccs-th-wrap">${c.label}`;
          if (isFilter) {
            const isActive = ccsState.filters[c.key] && ccsState.filters[c.key].length > 0;
            headerHTML += ` <span class="ccs-filter-btn${isActive ? ' active' : ''}" onclick="ccsToggleFilter(event,'${c.key}')" title="Filter"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M22 3H2l8 9.46V19l4 2v-8.54L22 3z"/></svg></span>`;
          }
          if (isSort) {
            let icon = '\u21C5';
            let cls = '';
            if (ccsState.sortCol === c.key && ccsState.sortDir) {
              icon = ccsState.sortDir === 'asc' ? '\u25B2' : '\u25BC';
              cls = ' active';
            }
            headerHTML += ` <span class="ccs-sort-btn${cls}" onclick="ccsCycleSort('${c.key}')" title="Sort">${icon}</span>`;
          }
          headerHTML += '</div></th>';
        }
      });
      thead.innerHTML = headerHTML;

      {
        const ths = thead.querySelectorAll('th');
        let left = 0;
        const fallbackWidths = [45, 100, 110];
        for (let i = 0; i < CCS_FROZEN_COUNT; i++) {
          ccsFrozenLeftCache[i] = left;
          ths[i].style.left = left + 'px';
          const w = ths[i].getBoundingClientRect().width;
          left += w > 0 ? w : fallbackWidths[i];
        }
      }

      const frozenStyle = (ci) => ci < CCS_FROZEN_COUNT ? `left:${ccsFrozenLeftCache[ci]}px;` : '';

      const { page, pageSize, serverTotalCount } = ccsState;

      // Get filtered and sorted rows (for client-side filtering if active)
      const displayRows = getCcsFilteredSortedRows();

      // Check if client-side filters are active
      const hasFilters = (ccsState.filters.cellNumber && ccsState.filters.cellNumber.length > 0) ||
                        (ccsState.filters.cellSelection && ccsState.filters.cellSelection.length > 0);

      // Calculate pagination:
      // - If filters active: use displayRows.length (client-side filtered count)
      // - If no filters: use serverTotalCount (total count from server)
      const totalCount = hasFilters ? displayRows.length : serverTotalCount;
      const totalPages = Math.max(1, Math.ceil(totalCount / pageSize));
      const startIdx = (page - 1) * pageSize;
      const endIdx = Math.min(startIdx + pageSize, displayRows.length);

      // Get rows for current page from displayRows
      const pageRows = displayRows.slice(startIdx, endIdx);

      let bodyHTML = '';
      if (pageRows.length === 0) {
        bodyHTML = `<tr><td colspan="${cols.length + 1}" style="padding:40px;color:#94A3B8;font-size:14px;">No data available for the selected period</td></tr>`;
      } else {
        pageRows.forEach((row, i) => {
          const rowIdx = startIdx + i;
          bodyHTML += `<tr class="ccs-data-row" data-row-idx="${rowIdx}" onclick="ccsToggleRowDetail(this, ${rowIdx})">`;
          bodyHTML += `<td class="${frozenCls(0)}" style="${frozenStyle(0)}color:#94A3B8;font-weight:500;">${rowIdx + 1}</td>`;
          cols.forEach((c, ci) => {
            let val = row[c.key];

            // Lazy calculation for coldSpotCathodes only when rendering
            if (c.key === 'coldSpotCathodes') {
              val = calculateColdSpotForRow(row);
            }

            if (val === null || val === undefined || val === '') val = null;
            const colIdx = ci + 1;
            const fc = frozenCls(colIdx);
            const fs = frozenStyle(colIdx);
            const fAttr = fc ? ` class="${fc}" style="${fs}"` : '';
            if (c.key === 'cellNumber') {
              bodyHTML += `<td class="${fc}" style="${fs}font-weight:600;color:#1E3A5F;">${val !== null ? 'Cell No ' + val : '--'}</td>`;
            } else if (c.key === 'cycleStart' || c.key === 'cycleEnd') {
              bodyHTML += `<td${fAttr}>${formatCcsDateTime(val)}</td>`;
            } else if (c.key === 'ce') {
              const v = val !== null ? parseFloat(val) : NaN;
              if (!isNaN(v)) {
                const cls = v >= state.thresholds.excellent.min ? 'ce-excellent' : v >= state.thresholds.good.min ? 'ce-good' : 'ce-bad';
                bodyHTML += `<td class="${cls}">${Math.round(v * 100) / 100}%</td>`;
              } else {
                bodyHTML += `<td>--</td>`;
              }
            } else if (c.key === 'badCathodes') {
              const v = val !== null ? parseInt(val) : NaN;
              if (!isNaN(v)) {
                bodyHTML += `<td class="${getBadCathodeClass(v)}">${v}</td>`;
              } else {
                bodyHTML += `<td>--</td>`;
              }
            } else if (c.key === 'cycleTime' || c.key === 'sumGoodWeight' || c.key === 'weight57' || c.key === 'busbarLoad') {
              const v = val !== null ? parseFloat(val) : NaN;
              bodyHTML += `<td${fAttr}>${!isNaN(v) ? (Math.round(v * 100) / 100) : '--'}</td>`;
            } else {
              bodyHTML += `<td${fAttr}>${val !== null ? val : '--'}</td>`;
            }
          });
          bodyHTML += '</tr>';
        });
      }
      tbody.innerHTML = bodyHTML;

      document.getElementById('ccsPageInfo').textContent = totalCount > 0
        ? `Showing ${startIdx + 1} - ${endIdx} of ${totalCount}`
        : 'No records';
      document.getElementById('ccsPageNum').textContent = `${page} / ${totalPages}`;
    }

    function ccsCycleSort(colKey) {
      if (ccsState.sortCol !== colKey) {
        ccsState.sortCol = colKey;
        ccsState.sortDir = 'asc';
      } else if (ccsState.sortDir === 'asc') {
        ccsState.sortDir = 'desc';
      } else {
        ccsState.sortCol = null;
        ccsState.sortDir = null;
      }
      ccsState.page = 1;
      renderCcsTable();
    }

    function ccsToggleFilter(event, colKey) {
      event.stopPropagation();
      const existing = document.querySelector('.ccs-filter-popup');
      if (existing) { existing.remove(); return; }

      const th = event.target.closest('th');
      const uniqueVals = [...new Set(ccsState.rows.map(r => r[colKey]).filter(v => v !== null && v !== undefined))];
      if (colKey === 'cellNumber') uniqueVals.sort((a, b) => Number(a) - Number(b));
      else uniqueVals.sort();

      const selected = ccsState.filters[colKey] ? new Set(ccsState.filters[colKey]) : new Set();
      const allSelected = selected.size === 0;

      const popup = document.createElement('div');
      popup.className = 'ccs-filter-popup';
      popup.onclick = e => e.stopPropagation();

      let html = `<input class="ccs-filter-search" type="text" placeholder="Search..." oninput="ccsFilterSearch(this)">`;
      html += `<label class="ccs-filter-all"><input type="checkbox" ${allSelected ? 'checked' : ''} onchange="ccsFilterToggleAll(this, '${colKey}')"> <strong>Select All</strong></label>`;
      uniqueVals.forEach(v => {
        const checked = allSelected || selected.has(String(v)) ? 'checked' : '';
        html += `<label data-val="${v}"><input type="checkbox" value="${v}" ${checked}> ${colKey === 'cellNumber' ? 'Cell ' + v : v}</label>`;
      });
      html += `<div class="ccs-filter-actions"><button onclick="ccsFilterClear('${colKey}')">Clear</button><button class="apply" onclick="ccsFilterApply('${colKey}')">Apply</button></div>`;
      popup.innerHTML = html;
      th.appendChild(popup);

      const closePopup = (e) => {
        if (!popup.contains(e.target) && e.target !== popup) {
          popup.remove();
          document.removeEventListener('click', closePopup);
        }
      };
      setTimeout(() => document.addEventListener('click', closePopup), 10);
    }

    function ccsFilterSearch(input) {
      const term = input.value.toLowerCase();
      const labels = input.parentElement.querySelectorAll('label[data-val]');
      labels.forEach(l => {
        l.style.display = l.dataset.val.toString().toLowerCase().includes(term) ? '' : 'none';
      });
    }

    function ccsFilterToggleAll(cb, colKey) {
      const popup = cb.closest('.ccs-filter-popup');
      const boxes = popup.querySelectorAll('label[data-val] input[type=checkbox]');
      boxes.forEach(b => b.checked = cb.checked);
    }

    function ccsFilterClear(colKey) {
      ccsState.filters[colKey] = null;
      ccsState.page = 1;
      const popup = document.querySelector('.ccs-filter-popup');
      if (popup) popup.remove();
      renderCcsTable();
    }

    function ccsFilterApply(colKey) {
      const popup = document.querySelector('.ccs-filter-popup');
      if (!popup) return;
      const allCb = popup.querySelector('.ccs-filter-all input');
      const boxes = popup.querySelectorAll('label[data-val] input[type=checkbox]:checked');
      const visibleBoxes = popup.querySelectorAll('label[data-val] input[type=checkbox]');
      if (allCb && allCb.checked && boxes.length === visibleBoxes.length) {
        ccsState.filters[colKey] = null;
      } else {
        ccsState.filters[colKey] = [...boxes].map(b => b.value);
      }
      ccsState.page = 1;
      popup.remove();
      renderCcsTable();
    }

    const ccsDetailCache = {};
    const ccsDetailPageState = {};
    let globalColdSpotThresholds = null; // Cached thresholds for export

    async function ccsToggleRowDetail(trEl, rowIdx) {
      const existing = trEl.nextElementSibling;
      if (existing && existing.classList.contains('ccs-detail-row')) {
        existing.remove();
        trEl.classList.remove('ccs-row-expanded');
        return;
      }
      document.querySelectorAll('.ccs-detail-row').forEach(r => r.remove());
      document.querySelectorAll('.ccs-data-row.ccs-row-expanded').forEach(r => r.classList.remove('ccs-row-expanded'));
      trEl.classList.add('ccs-row-expanded');

      // Get the filtered/sorted rows (same as in renderCcsTable)
      const displayRows = getCcsFilteredSortedRows();
      const row = displayRows[rowIdx];
      if (!row) return;

      const colSpan = CCS_CONFIG.columns.length + 1;
      const detailTr = document.createElement('tr');
      detailTr.className = 'ccs-detail-row';
      detailTr.innerHTML = `<td colspan="${colSpan}"><div class="ccs-detail-wrap"><div class="ccs-sub-loading"><div class="spinner" style="margin:0 auto 8px;width:22px;height:22px;border-width:2px;"></div>Loading...</div></div></td>`;
      trEl.after(detailTr);

      const cacheKey = `${row.strippingStart}_${row.strippingEnd}`;
      let cathodeRows;

      // First, try to populate cache if not already done
      if (!ccsDetailCache[cacheKey]) {
        console.log(` Cache miss for ${cacheKey}, calculating...`);
        // Try to calculate using existing cathode data cache
        calculateColdSpotForRow(row);
      }

      // Now check if cache is populated
      if (ccsDetailCache[cacheKey]) {
        cathodeRows = ccsDetailCache[cacheKey];
        console.log(` Using cached cathode data: ${cathodeRows.length} rows`);
      } else {
        // Fallback: fetch directly from API
        console.log(` Cache still empty, fetching from API...`);
        cathodeRows = await fetchCathodeDetail(row.strippingStart, row.strippingEnd);
        ccsDetailCache[cacheKey] = cathodeRows;
        console.log(` Fetched from API: ${cathodeRows.length} rows`);
      }

      if (!ccsDetailPageState[cacheKey]) ccsDetailPageState[cacheKey] = { page: 1, pageSize: 25, statusFilter: null };
      renderCcsSubTable(detailTr, cathodeRows, cacheKey, row);
    }

    // Fetch ALL cathode data for the entire date range in ONE API call
    async function fetchAllCathodeData(startDate, endDate) {
      const authVal = state.authToken.startsWith('Bearer ') ? state.authToken : 'Bearer ' + state.authToken;
      const allRows = [];
      let page = 1;
      const limit = 500; // Larger page size for bulk fetch
      let hasMore = true;

      try {
        while (hasMore) {
          const body = {
            devID: 'HZLCWT_A2',
            page, limit, rawData: true,
            sort: [{ D2: 'asc' }],
            search: {
              data: {
                D2: [{
                  startDate: startDate.toISOString(),
                  endDate: endDate.toISOString(),
                  timeFormat: 'YYYY-MM-DD HH:mm:ss'
                }]
              }
            }
          };
          const ctrl = new AbortController();
          const tid = setTimeout(() => ctrl.abort(), 30000);
          const resp = await fetch(CONFIG.apiBase + '/account/table/getRows3', {
            method: 'PUT',
            headers: { 'Authorization': authVal, 'Content-Type': 'application/json', 'Origin': CONFIG.origin },
            body: JSON.stringify(body),
            signal: ctrl.signal
          });
          clearTimeout(tid);
          const result = await resp.json();
          if (!result.success || !result.data) break;
          const rows = result.data.rows || [];
          rows.forEach(r => {
            const d = r.data || {};
            allRows.push({
              preTime: d.D0, postTime: d.D2,
              preWeight: d.D1, postWeight: d.D3,
              zincWeight: d.D4, status: d.D5
            });
          });
          if (page * limit >= (result.data.totalCount || 0)) hasMore = false;
          else page++;
        }
      } catch (e) { console.error('All cathode data fetch error:', e); }

      return allRows;
    }

    async function fetchCathodeDetail(startTime, endTime) {
      if (!startTime) return [];
      let effectiveEnd = endTime;
      if (!effectiveEnd || effectiveEnd === 'NaT' || effectiveEnd === 'null' || effectiveEnd === 'undefined') {
        const now = new Date();
        const y = now.getFullYear(), m = String(now.getMonth()+1).padStart(2,'0'), d = String(now.getDate()).padStart(2,'0');
        const hh = String(now.getHours()).padStart(2,'0'), mm = String(now.getMinutes()).padStart(2,'0'), ss = String(now.getSeconds()).padStart(2,'0');
        effectiveEnd = `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
      }
      const authVal = state.authToken.startsWith('Bearer ') ? state.authToken : 'Bearer ' + state.authToken;
      const allRows = [];
      let page = 1;
      const limit = 200;
      let hasMore = true;
      try {
        while (hasMore) {
          const body = {
            devID: 'HZLCWT_A2',
            page, limit, rawData: true,
            sort: [{ D2: 'asc' }],
            search: {
              data: {
                D2: [{
                  startDate: String(startTime),
                  endDate: String(effectiveEnd),
                  timeFormat: 'YYYY-MM-DD HH:mm:ss'
                }]
              }
            }
          };
          const ctrl = new AbortController();
          const tid = setTimeout(() => ctrl.abort(), 20000);
          const resp = await fetch(CONFIG.apiBase + '/account/table/getRows3', {
            method: 'PUT',
            headers: { 'Authorization': authVal, 'Content-Type': 'application/json', 'Origin': CONFIG.origin },
            body: JSON.stringify(body),
            signal: ctrl.signal
          });
          clearTimeout(tid);
          const result = await resp.json();
          if (!result.success || !result.data) break;
          const rows = result.data.rows || [];
          rows.forEach(r => {
            const d = r.data || {};
            allRows.push({
              preTime: d.D0, postTime: d.D2,
              preWeight: d.D1, postWeight: d.D3,
              zincWeight: d.D4, status: d.D5
            });
          });
          if (page * limit >= (result.data.totalCount || 0)) hasMore = false;
          else page++;
        }
      } catch (e) { console.error('Cathode detail fetch error:', e); }

      // Limit to maximum 57 rows as per requirements
      if (allRows.length > 57) {
        console.log(`  Limiting cathode rows from ${allRows.length} to 57`);
        allRows.splice(57); // Keep only first 57 rows
      }

      return allRows;
    }

    function getSubFilteredRows(cathodeRows, cacheKey) {
      const ps = ccsDetailPageState[cacheKey];
      if (!ps || !ps.statusFilter) return cathodeRows;
      return cathodeRows.filter(r => {
        const s = (r.status || '').toString().toUpperCase();
        return s === ps.statusFilter.toUpperCase();
      });
    }

    function renderCcsSubTable(detailTr, cathodeRows, cacheKey, parentRow) {
      const ps = ccsDetailPageState[cacheKey];
      const filtered = getSubFilteredRows(cathodeRows, cacheKey);
      const totalPages = Math.max(1, Math.ceil(filtered.length / ps.pageSize));
      if (ps.page > totalPages) ps.page = totalPages;
      const startIdx = (ps.page - 1) * ps.pageSize;
      const endIdx = Math.min(startIdx + ps.pageSize, filtered.length);
      const pageRows = filtered.slice(startIdx, endIdx);

      // Calculate cold spot counts for this cell
      const coldSpotCount = cathodeRows.filter(c => {
        const pw = parseFloat(c.preWeight);
        return !isNaN(pw) && pw < coldSpotThresholds.coldSpot;
      }).length;

      const singleSideCount = cathodeRows.filter(c => {
        const pw = parseFloat(c.preWeight);
        return !isNaN(pw) && pw > coldSpotThresholds.singleSideMin && pw <= coldSpotThresholds.singleSideMax;
      }).length;

      const doubleSideCount = cathodeRows.filter(c => {
        const pw = parseFloat(c.preWeight);
        return !isNaN(pw) && pw <= coldSpotThresholds.doubleSide;
      }).length;

      const subCols = [
        { key: 'sn', label: 'SN' },
        { key: 'postTime', label: 'Stripping Time' },
        { key: 'preTime', label: 'Pre-stripping Time' },
        { key: 'preWeight', label: 'Pre Stripping Weight' },
        { key: 'postWeight', label: 'Post Stripping Weight' },
        { key: 'zincWeight', label: 'Zinc Weight' },
        { key: 'coldCathodeStatus', label: 'Cold Cathode Status' },
        { key: 'status', label: 'Cathode Status' }
      ];

      const sf = ps.statusFilter;
      const filterActive = sf ? ' active' : '';

      let html = `<div class="ccs-detail-wrap">`;
      html += `<div class="ccs-sub-header">`;
      html += `<strong>Cathode Details &mdash; Cell No ${parentRow.cellNumber} &middot; ${parentRow.cellSelection} &nbsp;|&nbsp; ${cathodeRows.length} Cathodes`;
      html += ` &nbsp;|&nbsp; Cold Spot: ${coldSpotCount} &nbsp;|&nbsp; Single Side Cold: ${singleSideCount} &nbsp;|&nbsp; Double Side Cold: ${doubleSideCount}</strong>`;
      html += `<button class="ccs-sub-export-btn" onclick="exportCcsSubExcel('${cacheKey}')" title="Export to Excel"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> Export</button>`;
      html += `</div>`;
      html += `<div class="ccs-sub-table-wrap">`;
      html += `<table class="ccs-sub-table"><thead><tr>`;
      subCols.forEach(c => {
        if (c.key === 'status') {
          html += `<th><div class="ccs-th-wrap">${c.label} <span class="ccs-filter-btn${filterActive}" onclick="ccsSubStatusToggle(event,'${cacheKey}')" title="Filter"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M22 3H2l8 9.46V19l4 2v-8.54L22 3z"/></svg></span></div></th>`;
        } else {
          html += `<th>${c.label}</th>`;
        }
      });
      html += `</tr></thead><tbody>`;

      if (pageRows.length === 0) {
        html += `<tr><td colspan="${subCols.length}" style="padding:24px;color:#94A3B8;font-size:13px;">No cathode data found</td></tr>`;
      } else {
        pageRows.forEach((r, i) => {
          html += '<tr>';
          subCols.forEach(c => {
            if (c.key === 'sn') {
              html += `<td>${startIdx + i + 1}</td>`;
            } else if (c.key === 'coldCathodeStatus') {
              const pw = parseFloat(r.preWeight);
              const isDoubleSide = !isNaN(pw) && pw <= coldSpotThresholds.doubleSide;
              const isSingleSide = !isNaN(pw) && pw > coldSpotThresholds.singleSideMin && pw <= coldSpotThresholds.singleSideMax;

              if (isDoubleSide) {
                html += `<td style="text-align:center;"><span style="display:inline-block;padding:4px 10px;border-radius:12px;background:#FEE2E2;color:#DC2626;font-weight:600;font-size:11px;">Double side</span></td>`;
              } else if (isSingleSide) {
                html += `<td style="text-align:center;"><span style="display:inline-block;padding:4px 10px;border-radius:12px;background:#FFF7ED;color:#EA580C;font-weight:600;font-size:11px;">Single side</span></td>`;
              } else {
                html += `<td style="text-align:center;color:#94A3B8;">--</td>`;
              }
            } else if (c.key === 'status') {
              const s = (r.status || '').toString().toUpperCase();
              if (s === 'GOOD') {
                html += `<td class="status-good"><span style="display:inline-flex;align-items:center;gap:4px;padding:2px 10px;border-radius:12px;background:#DCFCE7;color:#16A34A;font-weight:600;font-size:11px;">&#10003; Good</span></td>`;
              } else if (s === 'BAD') {
                html += `<td class="status-bad"><span style="display:inline-flex;align-items:center;gap:4px;padding:2px 10px;border-radius:12px;background:#FEE2E2;color:#DC2626;font-weight:600;font-size:11px;">&#10007; Bad</span></td>`;
              } else {
                html += `<td>${r.status || '--'}</td>`;
              }
            } else if (c.key === 'preTime' || c.key === 'postTime') {
              html += `<td>${formatCcsDateTime(r[c.key])}</td>`;
            } else if (c.key === 'preWeight' || c.key === 'postWeight' || c.key === 'zincWeight') {
              const v = r[c.key] !== null && r[c.key] !== undefined ? parseFloat(r[c.key]) : NaN;
              html += `<td>${!isNaN(v) ? (Math.round(v * 100) / 100) : '--'}</td>`;
            } else {
              html += `<td>${r[c.key] || '--'}</td>`;
            }
          });
          html += '</tr>';
        });
      }
      html += '</tbody></table></div>';

      html += `<div class="ccs-sub-pagination">`;
      html += `<span>Showing ${filtered.length > 0 ? startIdx + 1 : 0} - ${endIdx} of ${filtered.length}${sf ? ' (filtered)' : ''}</span>`;
      html += `<span>Rows: <select onchange="ccsSubPageSize(this,'${cacheKey}')">`;
      [10, 25, 50, 100].forEach(n => {
        html += `<option value="${n}" ${ps.pageSize === n ? 'selected' : ''}>${n}</option>`;
      });
      html += `</select></span>`;
      html += `<span>`;
      html += `<button onclick="ccsSubGo('${cacheKey}','first')" ${ps.page <= 1 ? 'disabled' : ''}>&#171;</button> `;
      html += `<button onclick="ccsSubGo('${cacheKey}','prev')" ${ps.page <= 1 ? 'disabled' : ''}>&#8249;</button> `;
      html += ` ${ps.page} / ${totalPages} `;
      html += `<button onclick="ccsSubGo('${cacheKey}','next')" ${ps.page >= totalPages ? 'disabled' : ''}>&#8250;</button> `;
      html += `<button onclick="ccsSubGo('${cacheKey}','last')" ${ps.page >= totalPages ? 'disabled' : ''}>&#187;</button>`;
      html += `</span></div>`;
      html += `</div>`;

      detailTr.querySelector('td').innerHTML = html;
    }

    function ccsSubStatusToggle(event, cacheKey) {
      event.stopPropagation();
      const existing = event.target.closest('th').querySelector('.ccs-sub-status-popup');
      if (existing) { existing.remove(); return; }
      document.querySelectorAll('.ccs-sub-status-popup').forEach(p => p.remove());

      const ps = ccsDetailPageState[cacheKey];
      const sf = ps.statusFilter;
      const popup = document.createElement('div');
      popup.className = 'ccs-filter-popup ccs-sub-status-popup';
      popup.onclick = e => e.stopPropagation();
      popup.innerHTML = `
        <label style="padding:6px 12px;cursor:pointer;"><input type="radio" name="subStatus_${cacheKey}" value="" ${!sf ? 'checked' : ''} onchange="ccsSubStatusApply('${cacheKey}','')"> All</label>
        <label style="padding:6px 12px;cursor:pointer;"><input type="radio" name="subStatus_${cacheKey}" value="GOOD" ${sf==='GOOD' ? 'checked' : ''} onchange="ccsSubStatusApply('${cacheKey}','GOOD')"> <span style="color:#16A34A;font-weight:600;">Good</span></label>
        <label style="padding:6px 12px;cursor:pointer;"><input type="radio" name="subStatus_${cacheKey}" value="BAD" ${sf==='BAD' ? 'checked' : ''} onchange="ccsSubStatusApply('${cacheKey}','BAD')"> <span style="color:#DC2626;font-weight:600;">Bad</span></label>
      `;
      event.target.closest('th').appendChild(popup);
      setTimeout(() => {
        document.addEventListener('click', function handler() {
          popup.remove();
          document.removeEventListener('click', handler);
        }, { once: true });
      }, 0);
    }

    function ccsSubStatusApply(cacheKey, val) {
      const ps = ccsDetailPageState[cacheKey];
      ps.statusFilter = val || null;
      ps.page = 1;
      document.querySelectorAll('.ccs-sub-status-popup').forEach(p => p.remove());
      const detailTrs = document.querySelectorAll('.ccs-detail-row');
      for (const dtr of detailTrs) {
        const dataTr = dtr.previousElementSibling;
        if (!dataTr) continue;
        const rowIdx = parseInt(dataTr.dataset.rowIdx);
        const displayRows = getCcsFilteredSortedRows();
        const row = displayRows[rowIdx];
        if (!row) continue;
        const ck = `${row.strippingStart}_${row.strippingEnd}`;
        if (ck === cacheKey) {
          renderCcsSubTable(dtr, ccsDetailCache[cacheKey], cacheKey, row);
          break;
        }
      }
    }

    function exportCcsSubExcel(cacheKey) {
      const detailTrs = document.querySelectorAll('.ccs-detail-row');
      let parentRow = null;
      for (const dtr of detailTrs) {
        const dataTr = dtr.previousElementSibling;
        if (!dataTr) continue;
        const rowIdx = parseInt(dataTr.dataset.rowIdx);
        const displayRows = getCcsFilteredSortedRows();
        const row = displayRows[rowIdx];
        if (!row) continue;
        const ck = `${row.strippingStart}_${row.strippingEnd}`;
        if (ck === cacheKey) { parentRow = row; break; }
      }
      if (!parentRow) return;

      const cathodeRows = ccsDetailCache[cacheKey] || [];
      const filtered = getSubFilteredRows(cathodeRows, cacheKey);
      const cs = 'border:1px solid #CBD5E1;padding:6px 10px;text-align:center;font-size:12px;font-family:Inter,Arial,sans-serif;';
      const hs = cs + 'background:#1E3A5F;color:#FFFFFF;font-weight:600;';
      const hs2 = cs + 'background:#334155;color:#FFFFFF;font-weight:600;';

      const mainCols = CCS_CONFIG.columns;

      let html = '<table style="border-collapse:collapse;">';
      html += `<tr><th colspan="${mainCols.length + 1}" style="${cs}background:#0F172A;color:#fff;font-weight:700;font-size:14px;padding:10px;">Cathode Details - Cell No ${parentRow.cellNumber} &middot; ${parentRow.cellSelection}</th></tr>`;

      html += '<tr><th style="' + hs + '">#</th>';
      mainCols.forEach(c => { html += `<th style="${hs}">${c.label}</th>`; });
      html += '</tr>';
      html += '<tr><td style="' + cs + '">1</td>';
      mainCols.forEach(c => {
        let val = parentRow[c.key];
        if (val === null || val === undefined || val === '') val = '--';
        if (c.key === 'cycleStart' || c.key === 'cycleEnd') val = formatCcsDateTime(val);
        else if (c.key === 'ce') {
          const v = parseFloat(val);
          if (!isNaN(v)) {
            const bg = v >= state.thresholds.excellent.min ? '#DCFCE7' : v >= state.thresholds.good.min ? '#FFF7ED' : '#FEF2F2';
            const tc = v >= state.thresholds.excellent.min ? '#16A34A' : v >= state.thresholds.good.min ? '#EA580C' : '#DC2626';
            html += `<td style="${cs}background:${bg};color:${tc};font-weight:700;">${Math.round(v*100)/100}%</td>`;
            return;
          }
        } else if (c.key === 'badCathodes') {
          const v = parseInt(val);
          if (!isNaN(v)) {
            const rt = state.rejThresholds;
            const bg = v <= rt.excellent ? '#DCFCE7' : v <= rt.good ? '#FFF7ED' : '#FEF2F2';
            const tc = v <= rt.excellent ? '#16A34A' : v <= rt.good ? '#EA580C' : '#DC2626';
            html += `<td style="${cs}background:${bg};color:${tc};font-weight:700;">${v}</td>`;
            return;
          }
        } else if (c.key === 'cycleTime' || c.key === 'sumGoodWeight' || c.key === 'weight57' || c.key === 'busbarLoad') {
          const v = parseFloat(val);
          if (!isNaN(v)) val = Math.round(v*100)/100;
        } else if (c.key === 'cellNumber') {
          val = 'Cell No ' + parentRow.cellNumber;
        }
        html += `<td style="${cs}">${val}</td>`;
      });
      html += '</tr>';

      html += '<tr><td colspan="' + (mainCols.length + 1) + '" style="' + cs + 'height:6px;border:none;"></td></tr>';

      const subCols = ['SN','Stripping Time','Pre-stripping Time','Pre Stripping Weight','Post Stripping Weight','Zinc Weight','Cold Cathode Status','Cathode Status'];
      html += '<tr>';
      subCols.forEach(l => { html += `<th style="${hs2}">${l}</th>`; });
      if (subCols.length < mainCols.length + 1) {
        for (let x = subCols.length; x < mainCols.length + 1; x++) html += `<th style="${hs2}"></th>`;
      }
      html += '</tr>';

      // Load cold spot thresholds for export
      const coldSpotThresholds = globalColdSpotThresholds || COLD_SPOT_DEFAULTS;

      filtered.forEach((r, i) => {
        html += '<tr>';
        const s = (r.status || '').toString().toUpperCase();
        const statusBg = s === 'GOOD' ? '#DCFCE7' : s === 'BAD' ? '#FEE2E2' : '';
        const statusTc = s === 'GOOD' ? '#16A34A' : s === 'BAD' ? '#DC2626' : '#334155';

        // Calculate cold cathode status
        const pw = parseFloat(r.preWeight);
        const isDoubleSide = !isNaN(pw) && pw <= coldSpotThresholds.doubleSide;
        const isSingleSide = !isNaN(pw) && pw > coldSpotThresholds.singleSideMin && pw <= coldSpotThresholds.singleSideMax;
        const coldStatus = isDoubleSide ? 'Double side' : isSingleSide ? 'Single side' : '--';

        const vals = [
          i + 1,
          formatCcsDateTime(r.postTime),
          formatCcsDateTime(r.preTime),
          r.preWeight !== null && r.preWeight !== undefined ? (Math.round(parseFloat(r.preWeight)*100)/100 || '--') : '--',
          r.postWeight !== null && r.postWeight !== undefined ? (Math.round(parseFloat(r.postWeight)*100)/100 || '--') : '--',
          r.zincWeight !== null && r.zincWeight !== undefined ? (Math.round(parseFloat(r.zincWeight)*100)/100 || '--') : '--',
          coldStatus,
          r.status || '--'
        ];
        vals.forEach((v, vi) => {
          if (vi === vals.length - 1) {
            html += `<td style="${cs}background:${statusBg};color:${statusTc};font-weight:600;">${v}</td>`;
          } else if (vi === vals.length - 2) {
            // Cold Cathode Status column
            const coldBg = v === 'Double side' ? '#FEE2E2' : v === 'Single side' ? '#FFF7ED' : '';
            const coldTc = v === 'Double side' ? '#DC2626' : v === 'Single side' ? '#EA580C' : '#94A3B8';
            html += `<td style="${cs}background:${coldBg};color:${coldTc};font-weight:600;">${v}</td>`;
          } else {
            html += `<td style="${cs}">${v}</td>`;
          }
        });
        if (vals.length < mainCols.length + 1) {
          for (let x = vals.length; x < mainCols.length + 1; x++) html += `<td style="${cs}"></td>`;
        }
        html += '</tr>';
      });
      html += '</table>';

      const fullHtml = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
<head><meta charset="utf-8"><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>Cathode Details</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head>
<body>${html}</body></html>`;
      const blob = new Blob([fullHtml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
      const link = document.createElement('a');
      link.download = `Cathode_Details_Cell${parentRow.cellNumber}_${parentRow.cellSelection}_${new Date().toISOString().slice(0,10)}.xls`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function ccsSubPageSize(sel, cacheKey) {
      ccsDetailPageState[cacheKey].pageSize = parseInt(sel.value);
      ccsDetailPageState[cacheKey].page = 1;
      const detailTr = sel.closest('.ccs-detail-row');
      const displayRows = getCcsFilteredSortedRows();
      const dataTr = detailTr.previousElementSibling;
      const rowIdx = parseInt(dataTr.dataset.rowIdx);
      renderCcsSubTable(detailTr, ccsDetailCache[cacheKey], cacheKey, displayRows[rowIdx]);
    }

    function ccsSubGo(cacheKey, action) {
      const ps = ccsDetailPageState[cacheKey];
      const total = ccsDetailCache[cacheKey] ? ccsDetailCache[cacheKey].length : 0;
      const totalPages = Math.max(1, Math.ceil(total / ps.pageSize));
      if (action === 'first') ps.page = 1;
      else if (action === 'prev') ps.page = Math.max(1, ps.page - 1);
      else if (action === 'next') ps.page = Math.min(totalPages, ps.page + 1);
      else if (action === 'last') ps.page = totalPages;

      const detailTrs = document.querySelectorAll('.ccs-detail-row');
      for (const dtr of detailTrs) {
        const dataTr = dtr.previousElementSibling;
        if (!dataTr) continue;
        const rowIdx = parseInt(dataTr.dataset.rowIdx);
        const displayRows = getCcsFilteredSortedRows();
        const row = displayRows[rowIdx];
        if (!row) continue;
        const ck = `${row.strippingStart}_${row.strippingEnd}`;
        if (ck === cacheKey) {
          renderCcsSubTable(dtr, ccsDetailCache[cacheKey], cacheKey, row);
          break;
        }
      }
    }

    async function ccsChangePageSize() {
      const newPageSize = parseInt(document.getElementById('ccsPageSize').value);
      const oldPageSize = ccsState.pageSize;

      if (newPageSize === oldPageSize) return;

      ccsState.pageSize = newPageSize;
      ccsState.page = 1;

      // Clear loaded pages and reload data with new page size
      ccsState.rows = [];
      ccsState.loadedPages.clear();
      window.allCathodeDataCache = [];

      // Show inline loading indicator
      const loadingIndicator = document.getElementById('ccsPageLoadingIndicator');
      if (loadingIndicator) {
        loadingIndicator.style.display = 'inline';
      }

      // Disable pagination buttons during load
      const pageButtons = document.querySelectorAll('.ccs-page-btn');
      const pageSizeSelect = document.getElementById('ccsPageSize');
      pageButtons.forEach(btn => btn.disabled = true);
      if (pageSizeSelect) pageSizeSelect.disabled = true;

      try {
        await loadCcsPageData(1);
        await loadCathodeDataForVisibleRows();
      } catch (e) {
        console.error('Error changing page size:', e);
        alert('Error loading data. Please try again.');
      } finally {
        // Hide loading indicator and re-enable controls
        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }
        pageButtons.forEach(btn => btn.disabled = false);
        if (pageSizeSelect) pageSizeSelect.disabled = false;
        renderCcsTable();
      }
    }

    async function ccsGoPage(action) {
      const totalServerPages = Math.max(1, Math.ceil(ccsState.serverTotalCount / ccsState.pageSize));

      if (action === 'first') ccsState.page = 1;
      else if (action === 'prev') ccsState.page = Math.max(1, ccsState.page - 1);
      else if (action === 'next') ccsState.page = Math.min(totalServerPages, ccsState.page + 1);
      else if (action === 'last') ccsState.page = totalServerPages;

      // Check if we need to load more data from server
      const serverPage = ccsState.page;
      if (!ccsState.loadedPages.has(serverPage)) {
        // Show inline loading indicator
        const loadingIndicator = document.getElementById('ccsPageLoadingIndicator');
        if (loadingIndicator) {
          loadingIndicator.style.display = 'inline';
        }

        // Disable pagination buttons during load
        const pageButtons = document.querySelectorAll('.ccs-page-btn');
        const pageSizeSelect = document.getElementById('ccsPageSize');
        pageButtons.forEach(btn => btn.disabled = true);
        if (pageSizeSelect) pageSizeSelect.disabled = true;

        try {
          await loadCcsPageData(serverPage);
          await loadCathodeDataForVisibleRows();
        } catch (e) {
          console.error('Error loading page:', e);
          alert('Error loading page. Please try again.');
        } finally {
          // Hide loading indicator and re-enable controls
          if (loadingIndicator) {
            loadingIndicator.style.display = 'none';
          }
          pageButtons.forEach(btn => btn.disabled = false);
          if (pageSizeSelect) pageSizeSelect.disabled = false;
        }
      }

      renderCcsTable();
    }

    function toggleCcsExportMenu() {
      document.getElementById('ccsExportMenu').classList.toggle('show');
    }
    document.addEventListener('click', e => {
      if (!e.target.closest('#ccsExportDropdown')) document.getElementById('ccsExportMenu').classList.remove('show');
    });

    function exportCcsExcel() {
      document.getElementById('ccsExportMenu').classList.remove('show');
      const cols = CCS_CONFIG.columns;
      const cs = 'border:1px solid #E2E8F0;padding:6px 10px;text-align:center;font-size:12px;font-family:Inter,Arial,sans-serif;';
      const hs = cs + 'background:#1E3A5F;color:#FFFFFF;font-weight:600;';
      const side = state.currentSide === 'east' ? 'East Side CSM 2' : 'West Side';
      const exportRows = getCcsFilteredSortedRows();
      let html = '<table style="border-collapse:collapse;">';

      // Main header: Cell Efficiency Monitoring
      html += `<tr><th colspan="${cols.length + 1}" style="${cs}background:#0F172A;color:#FFFFFF;font-weight:700;font-size:16px;padding:12px;">Cell Efficiency Monitoring</th></tr>`;

      // Sub-header with dashboard context
      const subtitle = `Cell Cycle Summary | ${side}`;
      html += `<tr><th colspan="${cols.length + 1}" style="${cs}background:#1E3A5F;color:#FFFFFF;font-weight:600;font-size:14px;padding:10px;">${subtitle}</th></tr>`;

      // Duration line
      const duration = getFormattedDuration('ccs');
      html += `<tr><th colspan="${cols.length + 1}" style="${cs}background:#F0F4F8;color:#4A5568;font-weight:500;font-size:12px;padding:8px;">${duration}</th></tr>`;

      // Empty row for spacing
      html += `<tr><td colspan="${cols.length + 1}" style="height:10px;border:none;"></td></tr>`;

      // Column headers
      html += '<tr><th style="' + hs + '">#</th>';
      cols.forEach(c => { html += `<th style="${hs}">${c.label}</th>`; });
      html += '</tr>';
      exportRows.forEach((row, i) => {
        html += '<tr>';
        html += `<td style="${cs}">${i + 1}</td>`;
        cols.forEach(c => {
          let val = row[c.key];
          if (val === null || val === undefined || val === '') val = null;
          if (c.key === 'cycleStart' || c.key === 'cycleEnd') {
            html += `<td style="${cs}">${formatCcsDateTime(val)}</td>`;
          } else if (c.key === 'ce') {
            const v = val !== null ? parseFloat(val) : NaN;
            if (!isNaN(v)) {
              const bg = v >= state.thresholds.excellent.min ? '#DCFCE7' : v >= state.thresholds.good.min ? '#FFF7ED' : '#FEF2F2';
              const tc = v >= state.thresholds.excellent.min ? '#16A34A' : v >= state.thresholds.good.min ? '#EA580C' : '#DC2626';
              html += `<td style="${cs}background:${bg};color:${tc};font-weight:700;">${Math.round(v * 100) / 100}%</td>`;
            } else { html += `<td style="${cs}">--</td>`; }
          } else if (c.key === 'badCathodes') {
            const v = val !== null ? parseInt(val) : NaN;
            if (!isNaN(v)) {
              const rt = state.rejThresholds;
              const bg = v <= rt.excellent ? '#DCFCE7' : v <= rt.good ? '#FFF7ED' : '#FEF2F2';
              const tc = v <= rt.excellent ? '#16A34A' : v <= rt.good ? '#EA580C' : '#DC2626';
              html += `<td style="${cs}background:${bg};color:${tc};font-weight:700;">${v}</td>`;
            } else { html += `<td style="${cs}">--</td>`; }
          } else if (c.key === 'cycleTime' || c.key === 'sumGoodWeight' || c.key === 'weight57' || c.key === 'busbarLoad') {
            const v = val !== null ? parseFloat(val) : NaN;
            html += `<td style="${cs}">${!isNaN(v) ? Math.round(v * 100) / 100 : '--'}</td>`;
          } else {
            html += `<td style="${cs}">${val !== null ? val : '--'}</td>`;
          }
        });
        html += '</tr>';
      });
      html += '</table>';
      const fullHtml = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
<head><meta charset="utf-8"><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>Cell Cycle Summary</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head>
<body>${html}</body></html>`;
      const blob = new Blob([fullHtml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
      const link = document.createElement('a');
      const sideLabel = state.currentSide === 'east' ? 'East_Side' : 'West_Side';
      link.download = `Cell_Cycle_Summary_${sideLabel}_${new Date().toISOString().slice(0,10)}.xls`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    }

    /* ================================================
       INITIALIZATION
       ================================================ */
    function loadSavedThresholds() {
      const saved = localStorage.getItem('hzl_thresholds');
      if (saved) {
        try {
          Object.assign(state.thresholds, JSON.parse(saved));
        } catch (e) {}
      }
      const savedRej = localStorage.getItem('hzl_rejThresholds');
      if (savedRej) {
        try {
          Object.assign(state.rejThresholds, JSON.parse(savedRej));
        } catch (e) {}
      }
    }

    /* ================================================
       PDF EXPORT MODULE
       ================================================ */

    // Color mappings for PDF
    const STATUS_COLORS_PDF = {
      excellent: { r: 22, g: 163, b: 74, fillColor: [220, 252, 231] },  // Green
      good: { r: 234, g: 88, b: 12, fillColor: [255, 247, 237] },      // Orange
      bad: { r: 220, g: 38, b: 38, fillColor: [254, 242, 242] },       // Red
      nodata: { r: 148, g: 163, b: 184, fillColor: [241, 245, 249] }   // Gray
    };

    // Wrapper functions for menu items
    function exportTablePDF() {
      closeTableExportMenu();
      exportHeatmapPDF();
    }

    function exportCcsPDF() {
      document.getElementById('ccsExportMenu').classList.remove('show');
      exportCellCycleSummaryPDF();
    }

    // Helper function to get color from class name
    function getColorForClass(className) {
      if (className === 'cell-excellent') return { bg: '#DCFCE7', color: '#16A34A' };
      if (className === 'cell-good') return { bg: '#FFF7ED', color: '#EA580C' };
      if (className === 'cell-bad') return { bg: '#FEF2F2', color: '#DC2626' };
      return { bg: '#FAFAFA', color: '#CBD5E1' };
    }

    // Calculate optimal layout for PDF
    function calculatePDFLayout(dataRows, columns) {
      const orientation = dataRows.length > 50 || columns.length > 10 ? 'landscape' : 'portrait';
      const pageWidth = orientation === 'landscape' ? 297 : 210;
      const pageHeight = orientation === 'landscape' ? 210 : 297;
      const margins = { top: 20, left: 14, right: 14, bottom: 20 };

      return {
        orientation,
        pageWidth,
        pageHeight,
        margins,
        contentWidth: pageWidth - margins.left - margins.right,
        contentHeight: pageHeight - margins.top - margins.bottom
      };
    }

    // Export Cell Efficiency Heatmap to PDF (uses same data as Excel export)
    function exportHeatmapPDF() {
      try {
        const { jsPDF } = window.jspdf;

        // Use the same buildExportTable() function that Excel uses
        const htmlTable = buildExportTable();

        // Parse the HTML table to extract data
        const container = document.createElement('div');
        container.innerHTML = htmlTable;
        const table = container.querySelector('table');
        const rows = table.querySelectorAll('tr');

        // Determine orientation based on number of columns
        const firstDataRow = Array.from(rows).find(r => !r.querySelector('th[colspan]'));
        const colCount = firstDataRow ? firstDataRow.querySelectorAll('th, td').length : 10;
        const orientation = colCount > 10 ? 'landscape' : 'portrait';

        const doc = new jsPDF(orientation, 'mm', 'a4');
        const pageWidth = orientation === 'landscape' ? 297 : 210;
        const margins = { top: 10, left: 8, right: 8, bottom: 10 };

        // Convert HTML table rows to autoTable format
        const bodyData = [];

        rows.forEach((row, rowIndex) => {
          const cells = row.querySelectorAll('th, td');
          const rowData = [];

          cells.forEach(cell => {
            const text = cell.textContent.trim();
            const colspan = parseInt(cell.getAttribute('colspan')) || 1;
            const rowspan = parseInt(cell.getAttribute('rowspan')) || 1;
            const bgColor = cell.style.background || cell.style.backgroundColor || '';
            const textColor = cell.style.color || '';
            const fontWeight = cell.style.fontWeight || '';

            // Parse colors
            const fillColor = bgColor ? parseColor(bgColor) : null;
            const textColorRGB = textColor ? parseColor(textColor) : null;
            const isBold = fontWeight.includes('700') || fontWeight.includes('800') || fontWeight.includes('bold');

            // Determine font size based on row index
            let fontSize = 6; // Default for data rows
            if (rowIndex === 0) fontSize = 10;      // Main header
            else if (rowIndex === 1) fontSize = 9;  // Sub-header
            else if (rowIndex === 2) fontSize = 7;  // Duration
            else if (rowIndex === 4) fontSize = 7;  // Column headers

            rowData.push({
              content: text,
              colSpan: colspan,
              rowSpan: rowspan,
              styles: {
                fillColor: fillColor,
                textColor: textColorRGB,
                fontStyle: isBold ? 'bold' : 'normal',
                halign: 'center',
                valign: 'middle',
                fontSize: fontSize,
                cellPadding: rowIndex <= 2 ? 2 : 1
              }
            });
          });

          bodyData.push(rowData);
        });

        // Generate PDF with autoTable using html option
        doc.autoTable({
          body: bodyData,
          startY: margins.top,
          margin: margins,
          theme: 'grid',
          styles: {
            lineColor: [226, 232, 240],
            lineWidth: 0.1,
            overflow: 'linebreak'
          },
          pageBreak: 'auto',
          showHead: false
        });

        // Save the PDF
        const side = state.currentSide === 'east' ? 'East_Side' : 'West_Side';
        const filePrefix = activeDashConfig.rejectionMode ? 'Rejected_Cathode_Count' : 'Cell_Efficiency';
        const movAvgSuffix = state.cycleType === 'moving_avg' ? '_Moving_Avg' : '';
        const fileName = `${filePrefix}${movAvgSuffix}_${side}_${new Date().toISOString().slice(0,10)}.pdf`;
        doc.save(fileName);
      } catch (error) {
        console.error('PDF export error:', error);
        showError('PDF export failed: ' + error.message);
      }
    }

    // Helper function to parse CSS color to RGB array
    function parseColor(colorStr) {
      if (!colorStr) return undefined;

      // Handle hex colors
      if (colorStr.startsWith('#')) {
        const hex = colorStr.substring(1);
        if (hex.length === 3) {
          return [
            parseInt(hex[0] + hex[0], 16),
            parseInt(hex[1] + hex[1], 16),
            parseInt(hex[2] + hex[2], 16)
          ];
        } else if (hex.length === 6) {
          return [
            parseInt(hex.substring(0, 2), 16),
            parseInt(hex.substring(2, 4), 16),
            parseInt(hex.substring(4, 6), 16)
          ];
        }
      }

      // Handle rgb/rgba colors
      const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (match) {
        return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
      }

      return undefined;
    }

    // Export KPI Dashboard to PDF (uses same data as Excel export)
    function exportKpiPDF() {
      try {
        document.getElementById('kpiExportMenu').classList.remove('show');
        const { jsPDF } = window.jspdf;

        // Use the same buildKpiExportTable() function that Excel uses
        const htmlTable = buildKpiExportTable();
        if (!htmlTable) {
          showError('No KPI data to export');
          return;
        }

        // Parse the HTML table to extract data
        const container = document.createElement('div');
        container.innerHTML = htmlTable;
        const table = container.querySelector('table');
        const rows = table.querySelectorAll('tr');

        const doc = new jsPDF('landscape', 'mm', 'a4');
        const margins = { top: 10, left: 8, right: 8, bottom: 10 };

        // Convert HTML table rows to autoTable format
        const bodyData = [];

        rows.forEach((row, rowIndex) => {
          const cells = row.querySelectorAll('th, td');
          const rowData = [];

          cells.forEach(cell => {
            const text = cell.textContent.trim();
            const colspan = parseInt(cell.getAttribute('colspan')) || 1;
            const rowspan = parseInt(cell.getAttribute('rowspan')) || 1;
            const bgColor = cell.style.background || cell.style.backgroundColor || '';
            const textColor = cell.style.color || '';
            const fontWeight = cell.style.fontWeight || '';

            const fillColor = bgColor ? parseColor(bgColor) : null;
            const textColorRGB = textColor ? parseColor(textColor) : null;
            const isBold = fontWeight.includes('700') || fontWeight.includes('800') || fontWeight.includes('bold');

            // Determine font size based on row type
            let fontSize = 6;
            if (rowIndex === 0) fontSize = 10;  // Main header
            else if (rowIndex === 1) fontSize = 9;  // Sub-header
            else if (rowIndex === 2) fontSize = 7;  // Duration info
            else if (rowIndex === 4) fontSize = 7;  // Section headers
            else if (rowIndex === 5) fontSize = 7;  // Column headers

            rowData.push({
              content: text,
              colSpan: colspan,
              rowSpan: rowspan,
              styles: {
                fillColor: fillColor,
                textColor: textColorRGB,
                fontStyle: isBold ? 'bold' : 'normal',
                halign: 'center',
                valign: 'middle',
                fontSize: fontSize,
                cellPadding: rowIndex <= 2 ? 2 : 1
              }
            });
          });

          bodyData.push(rowData);
        });

        doc.autoTable({
          body: bodyData,
          startY: margins.top,
          margin: margins,
          theme: 'grid',
          styles: {
            lineColor: [226, 232, 240],
            lineWidth: 0.1,
            overflow: 'linebreak'
          },
          pageBreak: 'auto',
          showHead: false
        });

        // Save with same naming as Excel
        const side = state.currentSide === 'east' ? 'East_Side' : 'West_Side';
        const filePrefix = activeDashConfig.rejectionMode ? 'KPI_Rejected_Cathode' : 'KPI_Cell_Efficiency';
        const fileName = `${filePrefix}_${side}_${new Date().toISOString().slice(0,10)}.pdf`;
        doc.save(fileName);
      } catch (error) {
        console.error('KPI PDF export error:', error);
        showError('PDF export failed: ' + error.message);
      }
    }

    // Export Cell Cycle Summary to PDF
    function exportCellCycleSummaryPDF() {
      try {
        const { jsPDF } = window.jspdf;

        // Get table data
        const tbody = document.getElementById('ccs-body');
        if (!tbody) {
          showError('No data to export');
          return;
        }

        // Get column headers
        const thead = document.getElementById('ccs-header');
        const headers = [];
        const ths = thead.getElementsByTagName('th');
        for (let th of ths) {
          headers.push(th.textContent.trim());
        }

        // Get filtered and sorted rows (same as Excel export)
        const exportRows = getCcsFilteredSortedRows();
        const rows = exportRows.map(r => {
          const row = [];
          CCS_CONFIG.columns.forEach(col => {
            let val = r[col.key];
            if (col.key === 'cellNumber') {
              val = `Cell ${val}`;
            } else if (col.key === 'cellSelection') {
              val = val || '';
            } else if (col.key === 'startTime' || col.key === 'endTime') {
              val = val ? new Date(val).toLocaleString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
              }) : '';
            } else if (col.key === 'duration') {
              val = val || '';
            } else if (col.key === 'cathodeCount') {
              val = val || '0';
            } else if (col.key === 'coldSpotCount' || col.key === 'singleSideColdCount' || col.key === 'doubleSideColdCount') {
              val = val || '0';
            }
            row.push(val);
          });
          return row;
        });

        // Create landscape PDF for better fit
        const doc = new jsPDF('landscape', 'mm', 'a4');
        const pageWidth = 297;
        const margins = { top: 15, left: 10, right: 10, bottom: 10 };

        // Add header
        const sideInfo = state.currentSide === 'east' ? 'East Side CSM 2' : 'West Side';

        doc.setFont('helvetica', 'bold');
        doc.setFontSize(14);
        doc.setTextColor(30, 41, 59);
        doc.text('Cell Cycle Summary', margins.left, 10);

        doc.setFontSize(11);
        doc.setTextColor(51, 65, 85);
        doc.text(sideInfo, margins.left, 16);

        doc.setFont('helvetica', 'normal');
        doc.setFontSize(8);
        doc.setTextColor(100, 116, 139);
        const dateStr = new Date().toISOString().slice(0, 10);
        const periodLabel = document.querySelector('#dd-ccs-time .dropdown-label')?.textContent || '';
        doc.text(`Generated: ${dateStr} | Period: ${periodLabel} | Total Records: ${rows.length}`, margins.left, 21);

        // Add table with proper column widths
        doc.autoTable({
          head: [headers],
          body: rows,
          startY: 25,
          theme: 'grid',
          styles: {
            fontSize: 6,
            cellPadding: 1.5,
            overflow: 'linebreak',
            halign: 'center',
            valign: 'middle'
          },
          headStyles: {
            fillColor: [47, 64, 80],
            textColor: [255, 255, 255],
            fontSize: 7,
            fontStyle: 'bold',
            halign: 'center',
            cellPadding: 2
          },
          columnStyles: {
            0: { cellWidth: 18, halign: 'left', fontStyle: 'bold' }, // Cell Number
            1: { cellWidth: 15, halign: 'center' }, // Selection
            2: { cellWidth: 28, halign: 'center' }, // Start Time
            3: { cellWidth: 28, halign: 'center' }, // End Time
            4: { cellWidth: 20, halign: 'center' }, // Duration
            5: { cellWidth: 18, halign: 'center' }, // Cathode Count
            6: { cellWidth: 20, halign: 'center' }, // Cold Spot
            7: { cellWidth: 22, halign: 'center' }, // Single Side
            8: { cellWidth: 22, halign: 'center' }  // Double Side
          },
          margin: margins,
          pageBreak: 'auto',
          showHead: 'everyPage',
          tableWidth: 'auto'
        });

        // Save PDF
        const fileName = `Cell_Cycle_Summary_${sideInfo.replace(/ /g, '_')}_${dateStr}.pdf`;
        doc.save(fileName);
      } catch (error) {
        console.error('CCS PDF export error:', error);
        showError('PDF export failed: ' + error.message);
      }
    }

    async function init() {
      console.log('=== Application Starting ===');
      console.log('Current URL:', window.location.href);
      console.log('URL params:', window.location.search);

      // Try to authenticate first
      console.log(' Checking authentication...');
      if (!state.authToken) {
        await apiLogin();
      }

      loadSavedThresholds();
      await loadData();
    }

    // Start the application when DOM is ready
    window.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, initializing app...');
      init();
    });
  </script>
</body>
</html>
